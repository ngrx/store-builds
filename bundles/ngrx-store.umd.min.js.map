{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../modules/store/src/globals.ts","../../../../modules/store/src/action_creator.ts","../../../../modules/store/src/actions_subject.ts","../../../../modules/store/src/tokens.ts","../../../../modules/store/src/utils.ts","../../../../modules/store/src/reducer_manager.ts","../../../../modules/store/src/scanned_actions_subject.ts","../../../../modules/store/src/state.ts","../../../../modules/store/src/store.ts","../../../../modules/store/src/flags.ts","../../../../modules/store/src/selector.ts","../../../../modules/store/src/meta-reducers/utils.ts","../../../../modules/store/src/meta-reducers/immutability_reducer.ts","../../../../modules/store/src/meta-reducers/serialization_reducer.ts","../../../../modules/store/src/runtime_checks.ts","../../../../modules/store/src/meta-reducers/inNgZoneAssert_reducer.ts","../../../../modules/store/src/store_module.ts","../../../../modules/store/src/reducer_creator.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","REGISTERED_ACTION_TYPES","defineType","type","creator","defineProperty","writable","INIT","ActionsSubject","_super","action","complete","ngOnDestroy","BehaviorSubject","Injectable","ACTIONS_SUBJECT_PROVIDERS","_ROOT_STORE_GUARD","InjectionToken","_INITIAL_STATE","INITIAL_STATE","REDUCER_FACTORY","_REDUCER_FACTORY","INITIAL_REDUCERS","_INITIAL_REDUCERS","STORE_FEATURES","_STORE_REDUCERS","_FEATURE_REDUCERS","_FEATURE_CONFIGS","_STORE_FEATURES","_FEATURE_REDUCERS_TOKEN","FEATURE_REDUCERS","USER_PROVIDED_META_REDUCERS","META_REDUCERS","_RESOLVED_META_REDUCERS","USER_RUNTIME_CHECKS","_USER_RUNTIME_CHECKS","ACTIVE_RUNTIME_CHECKS","_ACTION_TYPE_UNIQUENESS_CHECK","combineReducers","reducers","initialState","reducerKeys","keys","finalReducers","key","finalReducerKeys","state","undefined","hasChanged","nextState","reducer","previousStateForKey","nextStateForKey","compose","functions","_i","arg","last","slice","reduceRight","composed","fn","createReducerFactory","reducerFactory","metaReducers","isArray","apply","ReducerObservable","Observable","ReducerManagerDispatcher","UPDATE","ReducerManager","dispatcher","_this","addFeature","feature","addFeatures","features","reduce","reducerDict","_a","createFeatureReducerFactory","addReducers","removeFeature","removeFeatures","removeReducers","map","addReducer","assign","updateReducers","removeReducer","featureKey","featureKeys","forEach","object","keyToRemove","filter","result","Inject","args","REDUCER_MANAGER_PROVIDERS","provide","useExisting","ScannedActionsSubject","Subject","SCANNED_ACTIONS_SUBJECT_PROVIDERS","StateObservable","State","actions$","reducer$","scannedActions","seed","stateAndAction$","pipe","observeOn","queueScheduler","withLatestFrom","scan","reduceState","stateSubscription","subscribe","unsubscribe","stateActionPair","_b","STATE_PROVIDERS","Store","state$","actionsObserver","reducerManager","source","select","pathOrMapFn","paths","lift","operator","store","dispatch","err","STORE_PROVIDERS","propsOrPath","source$","mapped$","pathSlices","Boolean","pluck","distinctUntilChanged","_ngrxMockEnvironment","isNgrxMockEnvironment","isEqualCheck","a","isArgumentsChanged","lastArguments","comparator","defaultMemoize","projectionFn","isArgumentsEqual","isResultEqual","overrideResult","lastResult","memoized","newResult","reset","setResult","clearResult","createSelector","input","createSelectorFactory","defaultStateFn","selectors","props","memoizedProjector","args_1","memoize","options","stateFn","head","tail","projector","memoizedSelectors","selector","release","memoizedState","RUNTIME_CHECK_URL","isUndefined","target","isNull","isObjectLike","isPlainObject","isObject","targetPrototype","getPrototypeOf","isFunction","freeze","targetIsFunction","getOwnPropertyNames","prop","startsWith","propertyName","propValue","isFrozen","getUnserializable","path","isComponent","isNumber","isBoolean","isString","throwIfUnserializable","unserializable","context","unserializablePath","join","Error","createActiveRuntimeChecks","runtimeChecks","isDevMode","strictStateSerializability","strictActionSerializability","strictStateImmutability","strictActionImmutability","strictActionWithinNgZone","strictActionTypeUniqueness","createSerializationCheckMetaReducer","checks","serializationCheckMetaReducer","ignoreNgrxAction","createImmutabilityCheckMetaReducer","act","immutabilityCheckMetaReducer","createInNgZoneCheckMetaReducer","ngCore.NgZone","isInAngularZone","inNgZoneAssertMetaReducer","provideRuntimeChecks","useValue","useFactory","_runtimeChecksFactory","deps","multi","checkForActionTypeUniqueness","_actionTypeUniquenessCheck","config","duplicates","entries","scannedActions$","guard","actionCheck","NgModule","Optional","StoreFeatureModule","featureReducers","root","feats","index","shift","_initialStateFactory","StoreRootModule","StoreModule","forRoot","ngModule","providers","_provideForRootGuard","SkipSelf","Injector","_createStoreReducers","_concatMetaReducers","forFeature","featureNameOrSlice","reducersOrConfig","name","_createFeatureStore","_createFeatureReducers","injector","get","configs","featureStores","feat","conf","reducerCollection","userProvidedMetaReducers","_as","featureName","featureState","console","warn","ons","Map","on_1","existingReducer","set","e_2","types","_c","ons_1","ons_1_1","pop","_p","creators"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export const REGISTERED_ACTION_TYPES: { [actionType: string]: number } = {};\n\nexport function resetRegisteredActionTypes() {\n  for (const key of Object.keys(REGISTERED_ACTION_TYPES)) {\n    delete REGISTERED_ACTION_TYPES[key];\n  }\n}\n","import {\n  Creator,\n  ActionCreator,\n  TypedAction,\n  FunctionWithParametersType,\n  NotAllowedCheck,\n  ActionCreatorProps,\n} from './models';\nimport { REGISTERED_ACTION_TYPES } from './globals';\n\n// Action creators taken from ts-action library and modified a bit to better\n// fit current NgRx usage. Thank you Nicholas Jamieson (@cartant).\n\nexport function createAction<T extends string>(\n  type: T\n): ActionCreator<T, () => TypedAction<T>>;\nexport function createAction<T extends string, P extends object>(\n  type: T,\n  config: ActionCreatorProps<P> & NotAllowedCheck<P>\n): ActionCreator<T, (props: P & NotAllowedCheck<P>) => P & TypedAction<T>>;\nexport function createAction<\n  T extends string,\n  P extends any[],\n  R extends object\n>(\n  type: T,\n  creator: Creator<P, R & NotAllowedCheck<R>>\n): FunctionWithParametersType<P, R & TypedAction<T>> & TypedAction<T>;\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nexport function createAction<T extends string, C extends Creator>(\n  type: T,\n  config?: { _as: 'props' } | C\n): ActionCreator<T> {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n\n  if (typeof config === 'function') {\n    return defineType(type, (...args: any[]) => ({\n      ...config(...args),\n      type,\n    }));\n  }\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type, () => ({ type }));\n    case 'props':\n      return defineType(type, (props: object) => ({\n        ...props,\n        type,\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\n\nexport function props<P extends object>(): ActionCreatorProps<P> {\n  return { _as: 'props', _p: undefined! };\n}\n\nexport function union<\n  C extends { [key: string]: ActionCreator<string, Creator> }\n>(creators: C): ReturnType<C[keyof C]> {\n  return undefined!;\n}\n\nfunction defineType<T extends string>(\n  type: T,\n  creator: Creator\n): ActionCreator<T> {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false,\n  });\n}\n","import { Injectable, OnDestroy, Provider } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\nimport { Action } from './models';\n\nexport const INIT = '@ngrx/store/init' as '@ngrx/store/init';\n\n@Injectable()\nexport class ActionsSubject extends BehaviorSubject<Action>\n  implements OnDestroy {\n  constructor() {\n    super({ type: INIT });\n  }\n\n  next(action: Action): void {\n    if (typeof action === 'function') {\n      throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n    } else if (typeof action === 'undefined') {\n      throw new TypeError(`Actions must be objects`);\n    } else if (typeof action.type === 'undefined') {\n      throw new TypeError(`Actions must have a type property`);\n    }\n    super.next(action);\n  }\n\n  complete() {\n    /* noop */\n  }\n\n  ngOnDestroy() {\n    super.complete();\n  }\n}\n\nexport const ACTIONS_SUBJECT_PROVIDERS: Provider[] = [ActionsSubject];\n","import { InjectionToken } from '@angular/core';\nimport { RuntimeChecks, MetaReducer } from './models';\n\nexport const _ROOT_STORE_GUARD = new InjectionToken<void>(\n  '@ngrx/store Internal Root Guard'\n);\nexport const _INITIAL_STATE = new InjectionToken(\n  '@ngrx/store Internal Initial State'\n);\nexport const INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nexport const REDUCER_FACTORY = new InjectionToken(\n  '@ngrx/store Reducer Factory'\n);\nexport const _REDUCER_FACTORY = new InjectionToken(\n  '@ngrx/store Internal Reducer Factory Provider'\n);\nexport const INITIAL_REDUCERS = new InjectionToken(\n  '@ngrx/store Initial Reducers'\n);\nexport const _INITIAL_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Initial Reducers'\n);\nexport const STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nexport const _STORE_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Store Reducers'\n);\nexport const _FEATURE_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Feature Reducers'\n);\n\nexport const _FEATURE_CONFIGS = new InjectionToken(\n  '@ngrx/store Internal Feature Configs'\n);\n\nexport const _STORE_FEATURES = new InjectionToken(\n  '@ngrx/store Internal Store Features'\n);\n\nexport const _FEATURE_REDUCERS_TOKEN = new InjectionToken(\n  '@ngrx/store Internal Feature Reducers Token'\n);\nexport const FEATURE_REDUCERS = new InjectionToken(\n  '@ngrx/store Feature Reducers'\n);\n\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\nexport const USER_PROVIDED_META_REDUCERS = new InjectionToken<MetaReducer[]>(\n  '@ngrx/store User Provided Meta Reducers'\n);\n\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\nexport const META_REDUCERS = new InjectionToken<MetaReducer[]>(\n  '@ngrx/store Meta Reducers'\n);\n\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\nexport const _RESOLVED_META_REDUCERS = new InjectionToken<MetaReducer>(\n  '@ngrx/store Internal Resolved Meta Reducers'\n);\n\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\nexport const USER_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store User Runtime Checks Config'\n);\n\n/**\n * Runtime checks defined by the user via forRoot()\n */\nexport const _USER_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store Internal User Runtime Checks Config'\n);\n\n/**\n * Runtime checks currently in use\n */\nexport const ACTIVE_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store Internal Runtime Checks'\n);\n\nexport const _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken<void>(\n  '@ngrx/store Check if Action types are unique'\n);\n","import {\n  Action,\n  ActionReducer,\n  ActionReducerFactory,\n  ActionReducerMap,\n  MetaReducer,\n  InitialState,\n} from './models';\n\nexport function combineReducers<T, V extends Action = Action>(\n  reducers: ActionReducerMap<T, V>,\n  initialState?: Partial<T>\n): ActionReducer<T, V>;\n/**\n * @description\n * Combines reducers for individual features into a single reducer.\n *\n * You can use this function to delegate handling of state transitions to multiple reducers, each acting on their\n * own sub-state within the root state.\n *\n * @param reducers An object mapping keys of the root state to their corresponding feature reducer.\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * **Example combining two feature reducers into one \"root\" reducer**\n *\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * });\n * ```\n *\n * You can also override the initial states of the sub-features:\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * }, {\n *   featureA: { counterA: 13 },\n *   featureB: { counterB: 37 }\n * });\n * ```\n */\nexport function combineReducers(\n  reducers: any,\n  initialState: any = {}\n): ActionReducer<any, Action> {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers: any = {};\n\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  return function combination(state, action) {\n    state = state === undefined ? initialState : state;\n    let hasChanged = false;\n    const nextState: any = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer: any = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\nexport function omit<T extends { [key: string]: any }>(\n  object: T,\n  keyToRemove: keyof T\n): Partial<T> {\n  return Object.keys(object)\n    .filter((key) => key !== keyToRemove)\n    .reduce((result, key) => Object.assign(result, { [key]: object[key] }), {});\n}\n\nexport function compose<A>(): (i: A) => A;\nexport function compose<A, B>(b: (i: A) => B): (i: A) => B;\nexport function compose<A, B, C>(c: (i: B) => C, b: (i: A) => B): (i: A) => C;\nexport function compose<A, B, C, D>(\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => D;\nexport function compose<A, B, C, D, E>(\n  e: (i: D) => E,\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => E;\nexport function compose<A, B, C, D, E, F>(\n  f: (i: E) => F,\n  e: (i: D) => E,\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => F;\nexport function compose<A = any, F = any>(...functions: any[]): (i: A) => F;\nexport function compose(...functions: any[]) {\n  return function (arg: any) {\n    if (functions.length === 0) {\n      return arg;\n    }\n\n    const last = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n\n    return rest.reduceRight((composed, fn) => fn(composed), last(arg));\n  };\n}\n\nexport function createReducerFactory<T, V extends Action = Action>(\n  reducerFactory: ActionReducerFactory<T, V>,\n  metaReducers?: MetaReducer<T, V>[]\n): ActionReducerFactory<T, V> {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    (reducerFactory as any) = compose.apply(null, [\n      ...metaReducers,\n      reducerFactory,\n    ]);\n  }\n\n  return (reducers: ActionReducerMap<T, V>, initialState?: InitialState<T>) => {\n    const reducer = reducerFactory(reducers);\n    return (state: T | undefined, action: V) => {\n      state = state === undefined ? (initialState as T) : state;\n      return reducer(state, action);\n    };\n  };\n}\n\nexport function createFeatureReducerFactory<T, V extends Action = Action>(\n  metaReducers?: MetaReducer<T, V>[]\n): (reducer: ActionReducer<T, V>, initialState?: T) => ActionReducer<T, V> {\n  const reducerFactory =\n    Array.isArray(metaReducers) && metaReducers.length > 0\n      ? compose<ActionReducer<T, V>>(...metaReducers)\n      : (r: ActionReducer<T, V>) => r;\n\n  return (reducer: ActionReducer<T, V>, initialState?: T) => {\n    reducer = reducerFactory(reducer);\n\n    return (state: T | undefined, action: V) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\n","import { Inject, Injectable, OnDestroy, Provider } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nimport { ActionsSubject } from './actions_subject';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerFactory,\n  ActionReducerMap,\n  StoreFeature,\n} from './models';\nimport { INITIAL_REDUCERS, INITIAL_STATE, REDUCER_FACTORY } from './tokens';\nimport {\n  createFeatureReducerFactory,\n  createReducerFactory,\n  omit,\n} from './utils';\n\nexport abstract class ReducerObservable extends Observable<\n  ActionReducer<any, any>\n> {}\nexport abstract class ReducerManagerDispatcher extends ActionsSubject {}\nexport const UPDATE = '@ngrx/store/update-reducers' as '@ngrx/store/update-reducers';\n\n@Injectable()\nexport class ReducerManager extends BehaviorSubject<ActionReducer<any, any>>\n  implements OnDestroy {\n  constructor(\n    private dispatcher: ReducerManagerDispatcher,\n    @Inject(INITIAL_STATE) private initialState: any,\n    @Inject(INITIAL_REDUCERS) private reducers: ActionReducerMap<any, any>,\n    @Inject(REDUCER_FACTORY)\n    private reducerFactory: ActionReducerFactory<any, any>\n  ) {\n    super(reducerFactory(reducers, initialState));\n  }\n\n  addFeature(feature: StoreFeature<any, any>) {\n    this.addFeatures([feature]);\n  }\n\n  addFeatures(features: StoreFeature<any, any>[]) {\n    const reducers = features.reduce(\n      (\n        reducerDict,\n        { reducers, reducerFactory, metaReducers, initialState, key }\n      ) => {\n        const reducer =\n          typeof reducers === 'function'\n            ? createFeatureReducerFactory(metaReducers)(reducers, initialState)\n            : createReducerFactory(reducerFactory, metaReducers)(\n                reducers,\n                initialState\n              );\n\n        reducerDict[key] = reducer;\n        return reducerDict;\n      },\n      {} as { [key: string]: ActionReducer<any, any> }\n    );\n\n    this.addReducers(reducers);\n  }\n\n  removeFeature(feature: StoreFeature<any, any>) {\n    this.removeFeatures([feature]);\n  }\n\n  removeFeatures(features: StoreFeature<any, any>[]) {\n    this.removeReducers(features.map((p) => p.key));\n  }\n\n  addReducer(key: string, reducer: ActionReducer<any, any>) {\n    this.addReducers({ [key]: reducer });\n  }\n\n  addReducers(reducers: { [key: string]: ActionReducer<any, any> }) {\n    this.reducers = { ...this.reducers, ...reducers };\n    this.updateReducers(Object.keys(reducers));\n  }\n\n  removeReducer(featureKey: string) {\n    this.removeReducers([featureKey]);\n  }\n\n  removeReducers(featureKeys: string[]) {\n    featureKeys.forEach((key) => {\n      this.reducers = omit(this.reducers, key) /*TODO(#823)*/ as any;\n    });\n    this.updateReducers(featureKeys);\n  }\n\n  private updateReducers(featureKeys: string[]) {\n    this.next(this.reducerFactory(this.reducers, this.initialState));\n    this.dispatcher.next(<Action>{\n      type: UPDATE,\n      features: featureKeys,\n    });\n  }\n\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n\nexport const REDUCER_MANAGER_PROVIDERS: Provider[] = [\n  ReducerManager,\n  { provide: ReducerObservable, useExisting: ReducerManager },\n  { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\n","import { Injectable, OnDestroy, Provider } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { Action } from './models';\n\n@Injectable()\nexport class ScannedActionsSubject extends Subject<Action>\n  implements OnDestroy {\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n\nexport const SCANNED_ACTIONS_SUBJECT_PROVIDERS: Provider[] = [\n  ScannedActionsSubject,\n];\n","import { Inject, Injectable, OnDestroy, Provider } from '@angular/core';\nimport {\n  BehaviorSubject,\n  Observable,\n  queueScheduler,\n  Subscription,\n} from 'rxjs';\nimport { observeOn, scan, withLatestFrom } from 'rxjs/operators';\n\nimport { ActionsSubject, INIT } from './actions_subject';\nimport { Action, ActionReducer } from './models';\nimport { ReducerObservable } from './reducer_manager';\nimport { ScannedActionsSubject } from './scanned_actions_subject';\nimport { INITIAL_STATE } from './tokens';\n\nexport abstract class StateObservable extends Observable<any> {}\n\n@Injectable()\nexport class State<T> extends BehaviorSubject<any> implements OnDestroy {\n  static readonly INIT = INIT;\n\n  private stateSubscription: Subscription;\n\n  constructor(\n    actions$: ActionsSubject,\n    reducer$: ReducerObservable,\n    scannedActions: ScannedActionsSubject,\n    @Inject(INITIAL_STATE) initialState: any\n  ) {\n    super(initialState);\n\n    const actionsOnQueue$: Observable<Action> = actions$.pipe(\n      observeOn(queueScheduler)\n    );\n    const withLatestReducer$: Observable<[\n      Action,\n      ActionReducer<any, Action>\n    ]> = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n\n    const seed: StateActionPair<T> = { state: initialState };\n    const stateAndAction$: Observable<{\n      state: any;\n      action?: Action;\n    }> = withLatestReducer$.pipe(\n      scan<[Action, ActionReducer<T, Action>], StateActionPair<T>>(\n        reduceState,\n        seed\n      )\n    );\n\n    this.stateSubscription = stateAndAction$.subscribe(({ state, action }) => {\n      this.next(state);\n      scannedActions.next(action!);\n    });\n  }\n\n  ngOnDestroy() {\n    this.stateSubscription.unsubscribe();\n    this.complete();\n  }\n}\n\nexport type StateActionPair<T, V extends Action = Action> = {\n  state: T | undefined;\n  action?: V;\n};\nexport function reduceState<T, V extends Action = Action>(\n  stateActionPair: StateActionPair<T, V> = { state: undefined },\n  [action, reducer]: [V, ActionReducer<T, V>]\n): StateActionPair<T, V> {\n  const { state } = stateActionPair;\n  return { state: reducer(state, action), action };\n}\n\nexport const STATE_PROVIDERS: Provider[] = [\n  State,\n  { provide: StateObservable, useExisting: State },\n];\n","import { Injectable, Provider } from '@angular/core';\nimport { Observable, Observer, Operator } from 'rxjs';\nimport { distinctUntilChanged, map, pluck } from 'rxjs/operators';\n\nimport { ActionsSubject } from './actions_subject';\nimport { Action, ActionReducer, FunctionIsNotAllowed } from './models';\nimport { ReducerManager } from './reducer_manager';\nimport { StateObservable } from './state';\n\n@Injectable()\nexport class Store<T = object> extends Observable<T>\n  implements Observer<Action> {\n  constructor(\n    state$: StateObservable,\n    private actionsObserver: ActionsSubject,\n    private reducerManager: ReducerManager\n  ) {\n    super();\n\n    this.source = state$;\n  }\n\n  select<K>(mapFn: (state: T) => K): Observable<K>;\n  select<K, Props = any>(\n    mapFn: (state: T, props: Props) => K,\n    props: Props\n  ): Observable<K>;\n  select<a extends keyof T>(key: a): Observable<T[a]>;\n  select<a extends keyof T, b extends keyof T[a]>(\n    key1: a,\n    key2: b\n  ): Observable<T[a][b]>;\n  select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(\n    key1: a,\n    key2: b,\n    key3: c\n  ): Observable<T[a][b][c]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c]\n  >(key1: a, key2: b, key3: c, key4: d): Observable<T[a][b][c][d]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d]\n  >(key1: a, key2: b, key3: c, key4: d, key5: e): Observable<T[a][b][c][d][e]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e]\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f\n  ): Observable<T[a][b][c][d][e][f]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e],\n    K = any\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f,\n    ...paths: string[]\n  ): Observable<K>;\n  select<Props = any, K = any>(\n    pathOrMapFn: ((state: T, props?: Props) => K) | string,\n    ...paths: string[]\n  ): Observable<any> {\n    return (select as any).call(null, pathOrMapFn, ...paths)(this);\n  }\n\n  lift<R>(operator: Operator<T, R>): Store<R> {\n    const store = new Store<R>(this, this.actionsObserver, this.reducerManager);\n    store.operator = operator;\n\n    return store;\n  }\n\n  dispatch<V extends Action = Action>(\n    action: V &\n      FunctionIsNotAllowed<\n        V,\n        'Functions are not allowed to be dispatched. Did you forget to call the action creator function?'\n      >\n  ) {\n    this.actionsObserver.next(action);\n  }\n\n  next(action: Action) {\n    this.actionsObserver.next(action);\n  }\n\n  error(err: any) {\n    this.actionsObserver.error(err);\n  }\n\n  complete() {\n    this.actionsObserver.complete();\n  }\n\n  addReducer<State, Actions extends Action = Action>(\n    key: string,\n    reducer: ActionReducer<State, Actions>\n  ) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n\n  removeReducer<Key extends Extract<keyof T, string>>(key: Key) {\n    this.reducerManager.removeReducer(key);\n  }\n}\n\nexport const STORE_PROVIDERS: Provider[] = [Store];\n\nexport function select<T, Props, K>(\n  mapFn: (state: T, props: Props) => K,\n  props?: Props\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, a extends keyof T>(\n  key: a\n): (source$: Observable<T>) => Observable<T[a]>;\nexport function select<T, a extends keyof T, b extends keyof T[a]>(\n  key1: a,\n  key2: b\n): (source$: Observable<T>) => Observable<T[a][b]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b]\n>(\n  key1: a,\n  key2: b,\n  key3: c\n): (source$: Observable<T>) => Observable<T[a][b][c]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d\n): (source$: Observable<T>) => Observable<T[a][b][c][d]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e],\n  K = any\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f,\n  ...paths: string[]\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, Props, K>(\n  pathOrMapFn: ((state: T, props?: Props) => any) | string,\n  propsOrPath?: Props | string,\n  ...paths: string[]\n) {\n  return function selectOperator(source$: Observable<T>): Observable<K> {\n    let mapped$: Observable<any>;\n\n    if (typeof pathOrMapFn === 'string') {\n      const pathSlices = [<string>propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(\n        map((source) => pathOrMapFn(source, <Props>propsOrPath))\n      );\n    } else {\n      throw new TypeError(\n        `Unexpected type '${typeof pathOrMapFn}' in select operator,` +\n          ` expected 'string' or 'function'`\n      );\n    }\n\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\n","let _ngrxMockEnvironment = false;\nexport function setNgrxMockEnvironment(value: boolean): void {\n  _ngrxMockEnvironment = value;\n}\nexport function isNgrxMockEnvironment(): boolean {\n  return _ngrxMockEnvironment;\n}\n","import { Selector, SelectorWithProps } from './models';\nimport { isDevMode } from '@angular/core';\nimport { isNgrxMockEnvironment } from './flags';\n\nexport type AnyFn = (...args: any[]) => any;\n\nexport type MemoizedProjection = {\n  memoized: AnyFn;\n  reset: () => void;\n  setResult: (result?: any) => void;\n  clearResult: () => void;\n};\n\nexport type MemoizeFn = (t: AnyFn) => MemoizedProjection;\n\nexport type ComparatorFn = (a: any, b: any) => boolean;\n\nexport type DefaultProjectorFn<T> = (...args: any[]) => T;\n\nexport interface MemoizedSelector<\n  State,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> extends Selector<State, Result> {\n  release(): void;\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n\nexport interface MemoizedSelectorWithProps<\n  State,\n  Props,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> extends SelectorWithProps<State, Props, Result> {\n  release(): void;\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n\nexport function isEqualCheck(a: any, b: any): boolean {\n  return a === b;\n}\n\nfunction isArgumentsChanged(\n  args: IArguments,\n  lastArguments: IArguments,\n  comparator: ComparatorFn\n) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function resultMemoize(\n  projectionFn: AnyFn,\n  isResultEqual: ComparatorFn\n) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\n\nexport function defaultMemoize(\n  projectionFn: AnyFn,\n  isArgumentsEqual = isEqualCheck,\n  isResultEqual = isEqualCheck\n): MemoizedProjection {\n  let lastArguments: null | IArguments = null;\n  // tslint:disable-next-line:no-any anything could be the result.\n  let lastResult: any = null;\n  let overrideResult: any;\n\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n\n  function setResult(result: any = undefined) {\n    overrideResult = { result };\n  }\n\n  function clearResult() {\n    overrideResult = undefined;\n  }\n\n  // tslint:disable-next-line:no-any anything could be the result.\n  function memoized(): any {\n    if (overrideResult !== undefined) {\n      return overrideResult.result;\n    }\n\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments as any);\n      lastArguments = arguments;\n      return lastResult;\n    }\n\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n\n    const newResult = projectionFn.apply(null, arguments as any);\n    lastArguments = arguments;\n\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n\n    lastResult = newResult;\n\n    return newResult;\n  }\n\n  return { memoized, reset, setResult, clearResult };\n}\n\nexport function createSelector<State, S1, Result>(\n  s1: Selector<State, S1>,\n  projector: (s1: S1) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, Result>(\n  selectors: [Selector<State, S1>],\n  projector: (s1: S1) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, Result>(\n  selectors: [SelectorWithProps<State, Props, S1>],\n  projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  projector: (s1: S1, s2: S2) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, Result>(\n  selectors: [Selector<State, S1>, Selector<State, S2>],\n  projector: (s1: S1, s2: S2) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>\n  ],\n  projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  projector: (s1: S1, s2: S2, s3: S3) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, Result>(\n  selectors: [Selector<State, S1>, Selector<State, S2>, Selector<State, S3>],\n  projector: (s1: S1, s2: S2, s3: S3) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, S4, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, S4, Result>(\n  selectors: [\n    Selector<State, S1>,\n    Selector<State, S2>,\n    Selector<State, S3>,\n    Selector<State, S4>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, S4, S5, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, S4, S5, Result>(\n  selectors: [\n    Selector<State, S1>,\n    Selector<State, S2>,\n    Selector<State, S3>,\n    Selector<State, S4>,\n    Selector<State, S5>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, Result>(\n  selectors: [\n    Selector<State, S1>,\n    Selector<State, S2>,\n    Selector<State, S3>,\n\n    Selector<State, S4>,\n    Selector<State, S5>,\n    Selector<State, S6>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  s7: Selector<State, S7>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  Result\n>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  s7: SelectorWithProps<State, Props, S7>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>(\n  selectors: [\n    Selector<State, S1>,\n    Selector<State, S2>,\n    Selector<State, S3>,\n    Selector<State, S4>,\n    Selector<State, S5>,\n    Selector<State, S6>,\n    Selector<State, S7>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  Result\n>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>,\n    SelectorWithProps<State, Props, S7>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  s7: Selector<State, S7>,\n  s8: Selector<State, S8>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8\n  ) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  S8,\n  Result\n>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  s7: SelectorWithProps<State, Props, S7>,\n  s8: SelectorWithProps<State, Props, S8>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>(\n  selectors: [\n    Selector<State, S1>,\n    Selector<State, S2>,\n    Selector<State, S3>,\n    Selector<State, S4>,\n    Selector<State, S5>,\n    Selector<State, S6>,\n    Selector<State, S7>,\n    Selector<State, S8>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8\n  ) => Result\n): MemoizedSelector<State, Result>;\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  S8,\n  Result\n>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>,\n    SelectorWithProps<State, Props, S7>,\n    SelectorWithProps<State, Props, S8>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;\n\nexport function createSelector(\n  ...input: any[]\n): MemoizedSelector<any, any> | MemoizedSelectorWithProps<any, any, any> {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\n\nexport function defaultStateFn(\n  state: any,\n  selectors: Selector<any, any>[] | SelectorWithProps<any, any, any>[],\n  props: any,\n  memoizedProjector: MemoizedProjection\n): any {\n  if (props === undefined) {\n    const args = (<Selector<any, any>[]>selectors).map((fn) => fn(state));\n    return memoizedProjector.memoized.apply(null, args);\n  }\n\n  const args = (<SelectorWithProps<any, any, any>[]>selectors).map((fn) =>\n    fn(state, props)\n  );\n  return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n\nexport type SelectorFactoryConfig<T = any, V = any> = {\n  stateFn: (\n    state: T,\n    selectors: Selector<any, any>[],\n    props: any,\n    memoizedProjector: MemoizedProjection\n  ) => V;\n};\n\nexport function createSelectorFactory<T = any, V = any>(\n  memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelector<T, V>;\nexport function createSelectorFactory<T = any, V = any>(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelector<T, V>;\nexport function createSelectorFactory<T = any, Props = any, V = any>(\n  memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;\nexport function createSelectorFactory<T = any, Props = any, V = any>(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;\n/**\n *\n * @param memoize The function used to memoize selectors\n * @param options Config Object that may include a `stateFn` function defining how to return the selector's value, given the entire `Store`'s state, parent `Selector`s, `Props`, and a `MemoizedProjection`\n *\n * @usageNotes\n *\n * **Creating a Selector Factory Where Array Order Does Not Matter**\n *\n * ```ts\n * function removeMatch(arr: string[], target: string): string[] {\n *   const matchIndex = arr.indexOf(target);\n *   return [...arr.slice(0, matchIndex), ...arr.slice(matchIndex + 1)];\n * }\n *\n * function orderDoesNotMatterComparer(a: any, b: any): boolean {\n *   if (!Array.isArray(a) || !Array.isArray(b)) {\n *     return a === b;\n *   }\n *   if (a.length !== b.length) {\n *     return false;\n *   }\n *   let tempB = [...b];\n *   function reduceToDetermineIfArraysContainSameContents(\n *     previousCallResult: boolean,\n *     arrayMember: any\n *   ): boolean {\n *     if (previousCallResult === false) {\n *       return false;\n *     }\n *     if (tempB.includes(arrayMember)) {\n *       tempB = removeMatch(tempB, arrayMember);\n *       return true;\n *     }\n *     return false;\n *   }\n *   return a.reduce(reduceToDetermineIfArraysContainSameContents, true);\n * }\n *\n * export const creactOrderDoesNotMatterSelector = createSelectorFactory(\n *   (projectionFun) => defaultMemoize(\n *     projectionFun,\n *     orderDoesNotMatterComparer,\n *     orderDoesNotMatterComparer\n *   )\n * );\n * ```\n *\n * **Creating an Alternative Memoization Strategy**\n *\n * ```ts\n * function serialize(x: any): string {\n *   return JSON.stringify(x);\n * }\n *\n * export const createFullHistorySelector = createSelectorFactory(\n *  (projectionFunction) => {\n *    const cache = {};\n *\n *    function memoized() {\n *      const serializedArguments = serialize(...arguments);\n *       if (cache[serializedArguments] != null) {\n *         cache[serializedArguments] = projectionFunction.apply(null, arguments);\n *       }\n *       return cache[serializedArguments];\n *     }\n *     return {\n *       memoized,\n *       reset: () => {},\n *       setResult: () => {},\n *       clearResult: () => {},\n *     };\n *   }\n * );\n * ```\n *\n *\n */\nexport function createSelectorFactory(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<any, any> = {\n    stateFn: defaultStateFn,\n  }\n) {\n  return function (\n    ...input: any[]\n  ): MemoizedSelector<any, any> | MemoizedSelectorWithProps<any, any, any> {\n    let args = input;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    }\n\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter(\n      (selector: any) =>\n        selector.release && typeof selector.release === 'function'\n    );\n\n    const memoizedProjector = memoize(function (...selectors: any[]) {\n      return projector.apply(null, selectors);\n    });\n\n    const memoizedState = defaultMemoize(function (state: any, props: any) {\n      return options.stateFn.apply(null, [\n        state,\n        selectors,\n        props,\n        memoizedProjector,\n      ]);\n    });\n\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n\n      memoizedSelectors.forEach((selector) => selector.release());\n    }\n\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult,\n    });\n  };\n}\n\nexport function createFeatureSelector<T>(\n  featureName: string\n): MemoizedSelector<object, T>;\nexport function createFeatureSelector<T, V>(\n  featureName: keyof T\n): MemoizedSelector<T, V>;\nexport function createFeatureSelector(\n  featureName: any\n): MemoizedSelector<any, any> {\n  return createSelector(\n    (state: any) => {\n      const featureState = state[featureName];\n      if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n        console.warn(\n          `@ngrx/store: The feature name \\\"${featureName}\\\" does ` +\n            'not exist in the state, therefore createFeatureSelector ' +\n            'cannot access it.  Be sure it is imported in a loaded module ' +\n            `using StoreModule.forRoot('${featureName}', ...) or ` +\n            `StoreModule.forFeature('${featureName}', ...).  If the default ` +\n            'state is intended to be undefined, as is the case with router ' +\n            'state, this development-only warning message can be ignored.'\n        );\n      }\n      return featureState;\n    },\n    (featureState: any) => featureState\n  );\n}\n","export const RUNTIME_CHECK_URL =\n  'https://ngrx.io/guide/store/configuration/runtime-checks';\n\nexport function isUndefined(target: any): target is undefined {\n  return target === undefined;\n}\n\nexport function isNull(target: any): target is null {\n  return target === null;\n}\n\nexport function isArray(target: any): target is Array<any> {\n  return Array.isArray(target);\n}\n\nexport function isString(target: any): target is string {\n  return typeof target === 'string';\n}\n\nexport function isBoolean(target: any): target is boolean {\n  return typeof target === 'boolean';\n}\n\nexport function isNumber(target: any): target is number {\n  return typeof target === 'number';\n}\n\nexport function isObjectLike(target: any): target is object {\n  return typeof target === 'object' && target !== null;\n}\n\nexport function isObject(target: any): target is object {\n  return isObjectLike(target) && !isArray(target);\n}\n\nexport function isPlainObject(target: any): target is object {\n  if (!isObject(target)) {\n    return false;\n  }\n\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\n\nexport function isFunction(target: any): target is Function {\n  return typeof target === 'function';\n}\n\nexport function isComponent(target: any) {\n  return isFunction(target) && target.hasOwnProperty('ɵcmp');\n}\n\nexport function hasOwnProperty(target: object, propertyName: string): boolean {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n","import { ActionReducer, Action } from '../models';\nimport { isFunction, hasOwnProperty, isObjectLike } from './utils';\n\nexport function immutabilityCheckMetaReducer(\n  reducer: ActionReducer<any, any>,\n  checks: { action: (action: Action) => boolean; state: () => boolean }\n): ActionReducer<any, any> {\n  return function (state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n\n    const nextState = reducer(state, act);\n\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\n\nfunction freeze(target: any) {\n  Object.freeze(target);\n\n  const targetIsFunction = isFunction(target);\n\n  Object.getOwnPropertyNames(target).forEach((prop) => {\n    // Ignore Ivy properties, ref: https://github.com/ngrx/platform/issues/2109#issuecomment-582689060\n    if (prop.startsWith('ɵ')) {\n      return;\n    }\n\n    if (\n      hasOwnProperty(target, prop) &&\n      (targetIsFunction\n        ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'\n        : true)\n    ) {\n      const propValue = target[prop];\n\n      if (\n        (isObjectLike(propValue) || isFunction(propValue)) &&\n        !Object.isFrozen(propValue)\n      ) {\n        freeze(propValue);\n      }\n    }\n  });\n\n  return target;\n}\n","import { ActionReducer, Action } from '../models';\nimport {\n  isPlainObject,\n  isUndefined,\n  isNull,\n  isNumber,\n  isBoolean,\n  isString,\n  isArray,\n  RUNTIME_CHECK_URL,\n  isComponent,\n} from './utils';\n\nexport function serializationCheckMetaReducer(\n  reducer: ActionReducer<any, any>,\n  checks: { action: (action: Action) => boolean; state: () => boolean }\n): ActionReducer<any, any> {\n  return function (state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, 'action');\n    }\n\n    const nextState = reducer(state, action);\n\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, 'state');\n    }\n\n    return nextState;\n  };\n}\n\nfunction getUnserializable(\n  target?: any,\n  path: string[] = []\n): false | { path: string[]; value: any } {\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target,\n    };\n  }\n\n  const keys = Object.keys(target);\n  return keys.reduce<false | { path: string[]; value: any }>((result, key) => {\n    if (result) {\n      return result;\n    }\n\n    const value = (target as any)[key];\n\n    // Ignore Ivy components\n    if (isComponent(value)) {\n      return result;\n    }\n\n    if (\n      isUndefined(value) ||\n      isNull(value) ||\n      isNumber(value) ||\n      isBoolean(value) ||\n      isString(value) ||\n      isArray(value)\n    ) {\n      return false;\n    }\n\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n\n    return {\n      path: [...path, key],\n      value,\n    };\n  }, false);\n}\n\nfunction throwIfUnserializable(\n  unserializable: false | { path: string[]; value: any },\n  context: 'state' | 'action'\n) {\n  if (unserializable === false) {\n    return;\n  }\n\n  const unserializablePath = unserializable.path.join('.');\n  const error: any = new Error(\n    `Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`\n  );\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\n","import { isDevMode, Provider } from '@angular/core';\nimport {\n  serializationCheckMetaReducer,\n  immutabilityCheckMetaReducer,\n  inNgZoneAssertMetaReducer,\n} from './meta-reducers';\nimport { RuntimeChecks, MetaReducer, Action } from './models';\nimport {\n  _USER_RUNTIME_CHECKS,\n  ACTIVE_RUNTIME_CHECKS,\n  META_REDUCERS,\n  USER_RUNTIME_CHECKS,\n  _ACTION_TYPE_UNIQUENESS_CHECK,\n} from './tokens';\nimport { REGISTERED_ACTION_TYPES } from './globals';\nimport { RUNTIME_CHECK_URL } from './meta-reducers/utils';\n\nexport function createActiveRuntimeChecks(\n  runtimeChecks?: Partial<RuntimeChecks>\n): RuntimeChecks {\n  if (isDevMode()) {\n    return {\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false,\n      ...runtimeChecks,\n    };\n  }\n\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false,\n  };\n}\n\nexport function createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionSerializability || strictStateSerializability\n      ? serializationCheckMetaReducer(reducer, {\n          action: (action) =>\n            strictActionSerializability && !ignoreNgrxAction(action),\n          state: () => strictStateSerializability,\n        })\n      : reducer;\n}\n\nexport function createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionImmutability || strictStateImmutability\n      ? immutabilityCheckMetaReducer(reducer, {\n          action: (action) =>\n            strictActionImmutability && !ignoreNgrxAction(action),\n          state: () => strictStateImmutability,\n        })\n      : reducer;\n}\n\nfunction ignoreNgrxAction(action: Action) {\n  return action.type.startsWith('@ngrx');\n}\n\nexport function createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionWithinNgZone\n      ? inNgZoneAssertMetaReducer(reducer, {\n          action: (action) =>\n            strictActionWithinNgZone && !ignoreNgrxAction(action),\n        })\n      : reducer;\n}\n\nexport function provideRuntimeChecks(\n  runtimeChecks?: Partial<RuntimeChecks>\n): Provider[] {\n  return [\n    {\n      provide: _USER_RUNTIME_CHECKS,\n      useValue: runtimeChecks,\n    },\n    {\n      provide: USER_RUNTIME_CHECKS,\n      useFactory: _runtimeChecksFactory,\n      deps: [_USER_RUNTIME_CHECKS],\n    },\n    {\n      provide: ACTIVE_RUNTIME_CHECKS,\n      deps: [USER_RUNTIME_CHECKS],\n      useFactory: createActiveRuntimeChecks,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createImmutabilityCheckMetaReducer,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createSerializationCheckMetaReducer,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createInNgZoneCheckMetaReducer,\n    },\n  ];\n}\n\nexport function checkForActionTypeUniqueness(): Provider[] {\n  return [\n    {\n      provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: _actionTypeUniquenessCheck,\n    },\n  ];\n}\n\nexport function _runtimeChecksFactory(\n  runtimeChecks: RuntimeChecks\n): RuntimeChecks {\n  return runtimeChecks;\n}\n\nexport function _actionTypeUniquenessCheck(config: RuntimeChecks): void {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES)\n    .filter(([, registrations]) => registrations > 1)\n    .map(([type]) => type);\n\n  if (duplicates.length) {\n    throw new Error(\n      `Action types are registered more than once, ${duplicates\n        .map((type) => `\"${type}\"`)\n        .join(', ')}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`\n    );\n  }\n}\n","import * as ngCore from '@angular/core';\nimport { Action, ActionReducer } from '../models';\nimport { RUNTIME_CHECK_URL } from './utils';\n\nexport function inNgZoneAssertMetaReducer(\n  reducer: ActionReducer<any, Action>,\n  checks: { action: (action: Action) => boolean }\n) {\n  return function (state: any, action: Action) {\n    if (checks.action(action) && !ngCore.NgZone.isInAngularZone()) {\n      throw new Error(\n        `Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`\n      );\n    }\n    return reducer(state, action);\n  };\n}\n","import {\n  NgModule,\n  Inject,\n  ModuleWithProviders,\n  OnDestroy,\n  InjectionToken,\n  Injector,\n  Optional,\n  SkipSelf,\n} from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerMap,\n  ActionReducerFactory,\n  StoreFeature,\n  InitialState,\n  MetaReducer,\n  RuntimeChecks,\n} from './models';\nimport { combineReducers, createReducerFactory } from './utils';\nimport {\n  INITIAL_STATE,\n  INITIAL_REDUCERS,\n  _INITIAL_REDUCERS,\n  REDUCER_FACTORY,\n  _REDUCER_FACTORY,\n  STORE_FEATURES,\n  _INITIAL_STATE,\n  META_REDUCERS,\n  _STORE_REDUCERS,\n  FEATURE_REDUCERS,\n  _FEATURE_REDUCERS,\n  _FEATURE_REDUCERS_TOKEN,\n  _STORE_FEATURES,\n  _FEATURE_CONFIGS,\n  USER_PROVIDED_META_REDUCERS,\n  _RESOLVED_META_REDUCERS,\n  _ROOT_STORE_GUARD,\n  ACTIVE_RUNTIME_CHECKS,\n  _ACTION_TYPE_UNIQUENESS_CHECK,\n} from './tokens';\nimport { ACTIONS_SUBJECT_PROVIDERS, ActionsSubject } from './actions_subject';\nimport {\n  REDUCER_MANAGER_PROVIDERS,\n  ReducerManager,\n  ReducerObservable,\n} from './reducer_manager';\nimport {\n  SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n  ScannedActionsSubject,\n} from './scanned_actions_subject';\nimport { STATE_PROVIDERS } from './state';\nimport { STORE_PROVIDERS, Store } from './store';\nimport {\n  provideRuntimeChecks,\n  checkForActionTypeUniqueness,\n} from './runtime_checks';\n\n@NgModule({})\nexport class StoreRootModule {\n  constructor(\n    actions$: ActionsSubject,\n    reducer$: ReducerObservable,\n    scannedActions$: ScannedActionsSubject,\n    store: Store<any>,\n    @Optional()\n    @Inject(_ROOT_STORE_GUARD)\n    guard: any,\n    @Optional()\n    @Inject(_ACTION_TYPE_UNIQUENESS_CHECK)\n    actionCheck: any\n  ) {}\n}\n\n@NgModule({})\nexport class StoreFeatureModule implements OnDestroy {\n  constructor(\n    @Inject(_STORE_FEATURES) private features: StoreFeature<any, any>[],\n    @Inject(FEATURE_REDUCERS) private featureReducers: ActionReducerMap<any>[],\n    private reducerManager: ReducerManager,\n    root: StoreRootModule,\n    @Optional()\n    @Inject(_ACTION_TYPE_UNIQUENESS_CHECK)\n    actionCheck: any\n  ) {\n    const feats = features.map((feature, index) => {\n      const featureReducerCollection = featureReducers.shift();\n      const reducers = featureReducerCollection /*TODO(#823)*/![index];\n\n      return {\n        ...feature,\n        reducers,\n        initialState: _initialStateFactory(feature.initialState),\n      };\n    });\n\n    reducerManager.addFeatures(feats);\n  }\n\n  ngOnDestroy() {\n    this.reducerManager.removeFeatures(this.features);\n  }\n}\n\nexport interface StoreConfig<T, V extends Action = Action> {\n  initialState?: InitialState<T>;\n  reducerFactory?: ActionReducerFactory<T, V>;\n  metaReducers?: MetaReducer<T, V>[];\n}\n\nexport interface RootStoreConfig<T, V extends Action = Action>\n  extends StoreConfig<T, V> {\n  runtimeChecks?: Partial<RuntimeChecks>;\n}\n\n/**\n * An object with the name and the reducer for the feature.\n */\nexport interface FeatureSlice<T, V extends Action = Action> {\n  name: string;\n  reducer: ActionReducer<T, V>;\n}\n\n@NgModule({})\nexport class StoreModule {\n  static forRoot<T, V extends Action = Action>(\n    reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n    config?: RootStoreConfig<T, V>\n  ): ModuleWithProviders<StoreRootModule>;\n  static forRoot(\n    reducers:\n      | ActionReducerMap<any, any>\n      | InjectionToken<ActionReducerMap<any, any>>,\n    config: RootStoreConfig<any, any> = {}\n  ): ModuleWithProviders<StoreRootModule> {\n    return {\n      ngModule: StoreRootModule,\n      providers: [\n        {\n          provide: _ROOT_STORE_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [[Store, new Optional(), new SkipSelf()]],\n        },\n        { provide: _INITIAL_STATE, useValue: config.initialState },\n        {\n          provide: INITIAL_STATE,\n          useFactory: _initialStateFactory,\n          deps: [_INITIAL_STATE],\n        },\n        { provide: _INITIAL_REDUCERS, useValue: reducers },\n        {\n          provide: _STORE_REDUCERS,\n          useExisting:\n            reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n        },\n        {\n          provide: INITIAL_REDUCERS,\n          deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n          useFactory: _createStoreReducers,\n        },\n        {\n          provide: USER_PROVIDED_META_REDUCERS,\n          useValue: config.metaReducers ? config.metaReducers : [],\n        },\n        {\n          provide: _RESOLVED_META_REDUCERS,\n          deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n          useFactory: _concatMetaReducers,\n        },\n        {\n          provide: _REDUCER_FACTORY,\n          useValue: config.reducerFactory\n            ? config.reducerFactory\n            : combineReducers,\n        },\n        {\n          provide: REDUCER_FACTORY,\n          deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n          useFactory: createReducerFactory,\n        },\n        ACTIONS_SUBJECT_PROVIDERS,\n        REDUCER_MANAGER_PROVIDERS,\n        SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n        STATE_PROVIDERS,\n        STORE_PROVIDERS,\n        provideRuntimeChecks(config.runtimeChecks),\n        checkForActionTypeUniqueness(),\n      ],\n    };\n  }\n\n  static forFeature<T, V extends Action = Action>(\n    featureName: string,\n    reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n    config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature<T, V extends Action = Action>(\n    featureName: string,\n    reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>,\n    config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature<T, V extends Action = Action>(\n    slice: FeatureSlice<T, V>,\n    config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature(\n    featureNameOrSlice: string | FeatureSlice<any, any>,\n    reducersOrConfig?:\n      | ActionReducerMap<any, any>\n      | InjectionToken<ActionReducerMap<any, any>>\n      | ActionReducer<any, any>\n      | InjectionToken<ActionReducer<any, any>>\n      | StoreConfig<any, any>\n      | InjectionToken<StoreConfig<any, any>>,\n    config: StoreConfig<any, any> | InjectionToken<StoreConfig<any, any>> = {}\n  ): ModuleWithProviders<StoreFeatureModule> {\n    return {\n      ngModule: StoreFeatureModule,\n      providers: [\n        {\n          provide: _FEATURE_CONFIGS,\n          multi: true,\n          useValue: featureNameOrSlice instanceof Object ? {} : config,\n        },\n        {\n          provide: STORE_FEATURES,\n          multi: true,\n          useValue: {\n            key:\n              featureNameOrSlice instanceof Object\n                ? featureNameOrSlice.name\n                : featureNameOrSlice,\n            reducerFactory:\n              !(config instanceof InjectionToken) && config.reducerFactory\n                ? config.reducerFactory\n                : combineReducers,\n            metaReducers:\n              !(config instanceof InjectionToken) && config.metaReducers\n                ? config.metaReducers\n                : [],\n            initialState:\n              !(config instanceof InjectionToken) && config.initialState\n                ? config.initialState\n                : undefined,\n          },\n        },\n        {\n          provide: _STORE_FEATURES,\n          deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n          useFactory: _createFeatureStore,\n        },\n        {\n          provide: _FEATURE_REDUCERS,\n          multi: true,\n          useValue:\n            featureNameOrSlice instanceof Object\n              ? featureNameOrSlice.reducer\n              : reducersOrConfig,\n        },\n        {\n          provide: _FEATURE_REDUCERS_TOKEN,\n          multi: true,\n          useExisting:\n            reducersOrConfig instanceof InjectionToken\n              ? reducersOrConfig\n              : _FEATURE_REDUCERS,\n        },\n        {\n          provide: FEATURE_REDUCERS,\n          multi: true,\n          deps: [\n            Injector,\n            _FEATURE_REDUCERS,\n            [new Inject(_FEATURE_REDUCERS_TOKEN)],\n          ],\n          useFactory: _createFeatureReducers,\n        },\n        checkForActionTypeUniqueness(),\n      ],\n    };\n  }\n}\n\nexport function _createStoreReducers(\n  injector: Injector,\n  reducers: ActionReducerMap<any, any>\n) {\n  return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\n\nexport function _createFeatureStore(\n  injector: Injector,\n  configs: StoreConfig<any, any>[] | InjectionToken<StoreConfig<any, any>>[],\n  featureStores: StoreFeature<any, any>[]\n) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = injector.get(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory\n          ? conf.reducerFactory\n          : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState,\n      };\n    }\n    return feat;\n  });\n}\n\nexport function _createFeatureReducers(\n  injector: Injector,\n  reducerCollection: ActionReducerMap<any, any>[]\n) {\n  const reducers = reducerCollection.map((reducer) => {\n    return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n  });\n\n  return reducers;\n}\n\nexport function _initialStateFactory(initialState: any): any {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n\n  return initialState;\n}\n\nexport function _concatMetaReducers(\n  metaReducers: MetaReducer[],\n  userProvidedMetaReducers: MetaReducer[]\n): MetaReducer[] {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\n\nexport function _provideForRootGuard(store: Store<any>): any {\n  if (store) {\n    throw new TypeError(\n      `StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { ActionCreator, ActionReducer, ActionType, Action } from './models';\n\n// Goes over the array of ActionCreators, pulls the action type out of each one\n// and returns the array of these action types.\ntype ExtractActionTypes<Creators extends readonly ActionCreator[]> = {\n  [Key in keyof Creators]: Creators[Key] extends ActionCreator<infer T>\n    ? T\n    : never;\n};\n\n/**\n * Return type of the `on` fn.\n * Contains the action reducer coupled to one or more action types.\n */\nexport interface ReducerTypes<\n  State,\n  Creators extends readonly ActionCreator[]\n> {\n  reducer: OnReducer<State, Creators>;\n  types: ExtractActionTypes<Creators>;\n}\n\n// Specialized Reducer that is aware of the Action type it needs to handle\nexport interface OnReducer<State, Creators extends readonly ActionCreator[]> {\n  (state: State, action: ActionType<Creators[number]>): State extends object\n    ? { [P in keyof State]: State[P] }\n    : State;\n}\n\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * @returns an association of action types with a state change function.\n *\n * @usageNotes\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n */\nexport function on<State, Creators extends readonly ActionCreator[]>(\n  ...args: [...creators: Creators, reducer: OnReducer<State, Creators>]\n): ReducerTypes<State, Creators> {\n  // This could be refactored when TS releases the version with this fix:\n  // https://github.com/microsoft/TypeScript/pull/41544\n  const reducer = args.pop() as OnReducer<State, Creators>;\n  const types = (((args as unknown) as Creators).map(\n    (creator) => creator.type\n  ) as unknown) as ExtractActionTypes<Creators>;\n  return { reducer, types };\n}\n\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.\n * - The returned `ActionReducer` should additionally be wrapped with another function, if you are using View Engine AOT.\n * In case you are using Ivy (or only JIT View Engine) the extra wrapper function is not required.\n *\n * **Declaring a reducer creator**\n *\n * ```ts\n * export const reducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n * ```\n *\n * **Declaring a reducer creator using a wrapper function (Only needed if using View Engine AOT)**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n */\nexport function createReducer<S, A extends Action = Action>(\n  initialState: S,\n  ...ons: ReducerTypes<S, ActionCreator[]>[]\n): ActionReducer<S, A> {\n  const map = new Map<string, OnReducer<S, ActionCreator[]>>();\n  for (let on of ons) {\n    for (let type of on.types) {\n      const existingReducer = map.get(type);\n      if (existingReducer) {\n        const newReducer: typeof existingReducer = (state, action) =>\n          on.reducer(existingReducer(state, action), action);\n        map.set(type, newReducer);\n      } else {\n        map.set(type, on.reducer);\n      }\n    }\n  }\n\n  return function (state: S = initialState, action: A): S {\n    const reducer = map.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n"]}