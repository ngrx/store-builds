{"version":3,"file":"models.js","sourceRoot":"ng://@ngrx/store/","sources":["src/models.ts"],"names":[],"mappings":";;;;;;;;AAAA,4BAEC;;;IADC,sBAAa;;;;;;;;AAoBf,mCAEC;;;;;AAMD,0CAKC;;;;;AAMD,kCAMC;;;IALC,2BAAY;;IACZ,gCAAuD;;IACvD,sCAA2C;;IAC3C,oCAA+B;;IAC/B,oCAAmC;;;AAUrC,MAAM,KAAO,sBAAsB,GACjC,2CAA2C;;AAG7C,MAAM,KAAO,2BAA2B,GACtC,iDAAiD;;;;;AA6BnD,2BAGC;;;IAFC,oBAAa;;IACb,mBAAM;;;;;AAWR,mCA2BC;;;;;;IAvBC,mDAAoC;;;;;IAIpC,oDAAqC;;;;;IAIrC,gDAAiC;;;;;IAIjC,iDAAkC;;;;;IAKlC,iDAAkC;;;;;IAKlC,mDAAqC","sourcesContent":["export interface Action {\n  type: string;\n}\n\n// declare to make it property-renaming safe\nexport declare interface TypedAction<T extends string> extends Action {\n  readonly type: T;\n}\n\nexport type ActionType<A> = A extends ActionCreator<infer T, infer C>\n  ? ReturnType<C> & { type: T }\n  : never;\n\nexport type TypeId<T> = () => T;\n\nexport type InitialState<T> = Partial<T> | TypeId<Partial<T>> | void;\n\n/**\n * A function that takes an `Action` and a `State`, and returns a `State`.\n * See `createReducer`.\n */\nexport interface ActionReducer<T, V extends Action = Action> {\n  (state: T | undefined, action: V): T;\n}\n\nexport type ActionReducerMap<T, V extends Action = Action> = {\n  [p in keyof T]: ActionReducer<T[p], V>;\n};\n\nexport interface ActionReducerFactory<T, V extends Action = Action> {\n  (\n    reducerMap: ActionReducerMap<T, V>,\n    initialState?: InitialState<T>\n  ): ActionReducer<T, V>;\n}\n\nexport type MetaReducer<T = any, V extends Action = Action> = (\n  reducer: ActionReducer<T, V>\n) => ActionReducer<T, V>;\n\nexport interface StoreFeature<T, V extends Action = Action> {\n  key: string;\n  reducers: ActionReducerMap<T, V> | ActionReducer<T, V>;\n  reducerFactory: ActionReducerFactory<T, V>;\n  initialState?: InitialState<T>;\n  metaReducers?: MetaReducer<T, V>[];\n}\n\nexport type Selector<T, V> = (state: T) => V;\n\nexport type SelectorWithProps<State, Props, Result> = (\n  state: State,\n  props: Props\n) => Result;\n\nexport const arraysAreNotAllowedMsg =\n  'arrays are not allowed in action creators';\ntype ArraysAreNotAllowed = typeof arraysAreNotAllowedMsg;\n\nexport const typePropertyIsNotAllowedMsg =\n  'type property is not allowed in action creators';\ntype TypePropertyIsNotAllowed = typeof typePropertyIsNotAllowedMsg;\n\nexport type FunctionIsNotAllowed<\n  T,\n  ErrorMessage extends string\n> = T extends Function ? ErrorMessage : T;\n/**\n * A function that returns an object in the shape of the `Action` interface.  Configured using `createAction`.\n */\nexport type Creator<\n  P extends any[] = any[],\n  R extends object = object\n> = FunctionWithParametersType<P, R>;\n\nexport type NotAllowedCheck<T extends object> = T extends any[]\n  ? ArraysAreNotAllowed\n  : T extends { type: any }\n  ? TypePropertyIsNotAllowed\n  : unknown;\n\n/**\n * See `Creator`.\n */\nexport type ActionCreator<\n  T extends string = string,\n  C extends Creator = Creator\n> = C & TypedAction<T>;\n\nexport interface Props<T> {\n  _as: 'props';\n  _p: T;\n}\n\nexport type FunctionWithParametersType<P extends unknown[], R = void> = (\n  ...args: P\n) => R;\n\nexport type ParametersType<T> = T extends (...args: infer U) => unknown\n  ? U\n  : never;\n\nexport interface RuntimeChecks {\n  /**\n   * Verifies if the state is serializable\n   */\n  strictStateSerializability: boolean;\n  /**\n   * Verifies if the actions are serializable. Please note, you may not need to set it to `true` unless you are storing/replaying actions using external resources, for example `localStorage`.\n   */\n  strictActionSerializability: boolean;\n  /**\n   * Verifies that the state isn't mutated\n   */\n  strictStateImmutability: boolean;\n  /**\n   * Verifies that actions aren't mutated\n   */\n  strictActionImmutability: boolean;\n\n  /**\n   * Verifies that actions are dispatched within NgZone\n   */\n  strictActionWithinNgZone: boolean;\n\n  /**\n   * Verifies that action types are not registered more than once\n   */\n  strictActionTypeUniqueness?: boolean;\n}\n"]}