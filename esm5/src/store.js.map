{"version":3,"file":"store.js","sourceRoot":"ng://@ngrx/store/","sources":["src/store.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, Provider } from '@angular/core';\nimport { Observable, Observer, Operator } from 'rxjs';\nimport { distinctUntilChanged, map, pluck } from 'rxjs/operators';\n\nimport { ActionsSubject } from './actions_subject';\nimport { Action, ActionReducer, FunctionIsNotAllowed } from './models';\nimport { ReducerManager } from './reducer_manager';\nimport { StateObservable } from './state';\n\n@Injectable()\nexport class Store<T = object> extends Observable<T>\n  implements Observer<Action> {\n  constructor(\n    state$: StateObservable,\n    private actionsObserver: ActionsSubject,\n    private reducerManager: ReducerManager\n  ) {\n    super();\n\n    this.source = state$;\n  }\n\n  select<K>(mapFn: (state: T) => K): Observable<K>;\n  select<K, Props = any>(\n    mapFn: (state: T, props: Props) => K,\n    props: Props\n  ): Observable<K>;\n  select<a extends keyof T>(key: a): Observable<T[a]>;\n  select<a extends keyof T, b extends keyof T[a]>(\n    key1: a,\n    key2: b\n  ): Observable<T[a][b]>;\n  select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(\n    key1: a,\n    key2: b,\n    key3: c\n  ): Observable<T[a][b][c]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c]\n  >(key1: a, key2: b, key3: c, key4: d): Observable<T[a][b][c][d]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d]\n  >(key1: a, key2: b, key3: c, key4: d, key5: e): Observable<T[a][b][c][d][e]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e]\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f\n  ): Observable<T[a][b][c][d][e][f]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e],\n    K = any\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f,\n    ...paths: string[]\n  ): Observable<K>;\n  select<Props = any, K = any>(\n    pathOrMapFn: ((state: T, props?: Props) => K) | string,\n    ...paths: string[]\n  ): Observable<any> {\n    return (select as any).call(null, pathOrMapFn, ...paths)(this);\n  }\n\n  lift<R>(operator: Operator<T, R>): Store<R> {\n    const store = new Store<R>(this, this.actionsObserver, this.reducerManager);\n    store.operator = operator;\n\n    return store;\n  }\n\n  dispatch<V extends Action = Action>(\n    action: V &\n      FunctionIsNotAllowed<\n        V,\n        'Functions are not allowed to be dispatched. Did you forget to call the action creator function?'\n      >\n  ) {\n    this.actionsObserver.next(action);\n  }\n\n  next(action: Action) {\n    this.actionsObserver.next(action);\n  }\n\n  error(err: any) {\n    this.actionsObserver.error(err);\n  }\n\n  complete() {\n    this.actionsObserver.complete();\n  }\n\n  addReducer<State, Actions extends Action = Action>(\n    key: string,\n    reducer: ActionReducer<State, Actions>\n  ) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n\n  removeReducer<Key extends Extract<keyof T, string>>(key: Key) {\n    this.reducerManager.removeReducer(key);\n  }\n}\n\nexport const STORE_PROVIDERS: Provider[] = [Store];\n\nexport function select<T, Props, K>(\n  mapFn: (state: T, props: Props) => K,\n  props?: Props\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, a extends keyof T>(\n  key: a\n): (source$: Observable<T>) => Observable<T[a]>;\nexport function select<T, a extends keyof T, b extends keyof T[a]>(\n  key1: a,\n  key2: b\n): (source$: Observable<T>) => Observable<T[a][b]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b]\n>(\n  key1: a,\n  key2: b,\n  key3: c\n): (source$: Observable<T>) => Observable<T[a][b][c]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d\n): (source$: Observable<T>) => Observable<T[a][b][c][d]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e],\n  K = any\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f,\n  ...paths: string[]\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, Props, K>(\n  pathOrMapFn: ((state: T, props?: Props) => any) | string,\n  propsOrPath?: Props | string,\n  ...paths: string[]\n) {\n  return function selectOperator(source$: Observable<T>): Observable<K> {\n    let mapped$: Observable<any>;\n\n    if (typeof pathOrMapFn === 'string') {\n      const pathSlices = [<string>propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(\n        map(source => pathOrMapFn(source, <Props>propsOrPath))\n      );\n    } else {\n      throw new TypeError(\n        `Unexpected type '${typeof pathOrMapFn}' in select operator,` +\n          ` expected 'string' or 'function'`\n      );\n    }\n\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\n"]}