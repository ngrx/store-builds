{"version":3,"file":"action_creator.js","sourceRoot":"ng://@ngrx/store/","sources":["src/action_creator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,OAAO,EAAE,uBAAuB,EAAE,MAAM,WAAW,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4FpD,MAAM,UAAU,YAAY,CAC1B,IAAO,EACP,MAA6B;IAE7B,uBAAuB,CAAC,IAAI,CAAC,GAAG,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IAEzE,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;QAChC,OAAO,UAAU,CAAC,IAAI;;;;QAAE;YAAC,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAAK,OAAA,uBACvC,MAAM,wBAAI,IAAI,OACjB,IAAI,MAAA,IACJ;QAH0C,CAG1C,EAAC,CAAC;KACL;;QACK,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO;IACxC,QAAQ,EAAE,EAAE;QACV,KAAK,OAAO;YACV,OAAO,UAAU,CAAC,IAAI;;;YAAE,cAAM,OAAA,CAAC,EAAE,IAAI,MAAA,EAAE,CAAC,EAAV,CAAU,EAAC,CAAC;QAC5C,KAAK,OAAO;YACV,OAAO,UAAU,CAAC,IAAI;;;;YAAE,UAAC,KAAa,IAAK,OAAA,uBACtC,KAAK,KACR,IAAI,MAAA,IACJ,EAHyC,CAGzC,EAAC,CAAC;QACN;YACE,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;KACzC;AACH,CAAC;;;;;AAED,MAAM,UAAU,KAAK;IACnB,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,mBAAA,SAAS,EAAC,EAAE,CAAC;AAC1C,CAAC;;;;;;AAED,MAAM,UAAU,KAAK,CAEnB,QAAW;IACX,OAAO,mBAAA,SAAS,EAAC,CAAC;AACpB,CAAC;;;;;;;AAED,SAAS,UAAU,CACjB,IAAO,EACP,OAAgB;IAEhB,OAAO,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE;QAC5C,KAAK,EAAE,IAAI;QACX,QAAQ,EAAE,KAAK;KAChB,CAAC,CAAC;AACL,CAAC","sourcesContent":["import {\n  Creator,\n  ActionCreator,\n  TypedAction,\n  FunctionWithParametersType,\n  NotAllowedCheck,\n  Props,\n} from './models';\nimport { REGISTERED_ACTION_TYPES } from './globals';\n\n// Action creators taken from ts-action library and modified a bit to better\n// fit current NgRx usage. Thank you Nicholas Jamieson (@cartant).\n\nexport function createAction<T extends string>(\n  type: T\n): ActionCreator<T, () => TypedAction<T>>;\nexport function createAction<T extends string, P extends object>(\n  type: T,\n  config: Props<P> & NotAllowedCheck<P>\n): ActionCreator<T, (props: P & NotAllowedCheck<P>) => P & TypedAction<T>>;\nexport function createAction<\n  T extends string,\n  P extends any[],\n  R extends object\n>(\n  type: T,\n  creator: Creator<P, R> & NotAllowedCheck<R>\n): FunctionWithParametersType<P, R & TypedAction<T>> & TypedAction<T>;\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nexport function createAction<T extends string, C extends Creator>(\n  type: T,\n  config?: { _as: 'props' } | C\n): ActionCreator<T> {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n\n  if (typeof config === 'function') {\n    return defineType(type, (...args: any[]) => ({\n      ...config(...args),\n      type,\n    }));\n  }\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type, () => ({ type }));\n    case 'props':\n      return defineType(type, (props: object) => ({\n        ...props,\n        type,\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\n\nexport function props<P extends object>(): Props<P> {\n  return { _as: 'props', _p: undefined! };\n}\n\nexport function union<\n  C extends { [key: string]: ActionCreator<string, Creator> }\n>(creators: C): ReturnType<C[keyof C]> {\n  return undefined!;\n}\n\nfunction defineType<T extends string>(\n  type: T,\n  creator: Creator\n): ActionCreator<T> {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false,\n  });\n}\n"]}