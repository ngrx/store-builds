{
  "version": 3,
  "sources": ["../../../../modules/store/src/globals.ts", "../../../../modules/store/src/action_creator.ts", "../../../../modules/store/src/helpers.ts", "../../../../modules/store/src/action_group_creator.ts", "../../../../modules/store/src/actions_subject.ts", "../../../../modules/store/src/tokens.ts", "../../../../modules/store/src/utils.ts", "../../../../modules/store/src/reducer_manager.ts", "../../../../modules/store/src/scanned_actions_subject.ts", "../../../../modules/store/src/state.ts", "../../../../modules/store/src/store.ts", "../../../../modules/store/src/meta-reducers/utils.ts", "../../../../modules/store/src/flags.ts", "../../../../modules/store/src/selector.ts", "../../../../modules/store/src/feature_creator.ts", "../../../../modules/store/src/store_config.ts", "../../../../modules/store/src/meta-reducers/immutability_reducer.ts", "../../../../modules/store/src/meta-reducers/serialization_reducer.ts", "../../../../modules/store/src/meta-reducers/inNgZoneAssert_reducer.ts", "../../../../modules/store/src/runtime_checks.ts", "../../../../modules/store/src/provide_store.ts", "../../../../modules/store/src/store_module.ts", "../../../../modules/store/src/reducer_creator.ts"],
  "sourcesContent": ["export const REGISTERED_ACTION_TYPES: { [actionType: string]: number } = {};\n\nexport function resetRegisteredActionTypes() {\n  for (const key of Object.keys(REGISTERED_ACTION_TYPES)) {\n    delete REGISTERED_ACTION_TYPES[key];\n  }\n}\n", "import {\n  Creator,\n  ActionCreator,\n  Action,\n  FunctionWithParametersType,\n  NotAllowedCheck,\n  ActionCreatorProps,\n  NotAllowedInPropsCheck,\n} from './models';\nimport { REGISTERED_ACTION_TYPES } from './globals';\n\n// Action creators taken from ts-action library and modified a bit to better\n// fit current NgRx usage. Thank you Nicholas Jamieson (@cartant).\n\nexport function createAction<T extends string>(\n  type: T\n): ActionCreator<T, () => Action<T>>;\nexport function createAction<T extends string, P extends object>(\n  type: T,\n  config: ActionCreatorProps<P> & NotAllowedCheck<P>\n): ActionCreator<T, (props: P & NotAllowedCheck<P>) => P & Action<T>>;\nexport function createAction<\n  T extends string,\n  P extends any[],\n  R extends object\n>(\n  type: T,\n  creator: Creator<P, R & NotAllowedCheck<R>>\n): FunctionWithParametersType<P, R & Action<T>> & Action<T>;\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nexport function createAction<T extends string, C extends Creator>(\n  type: T,\n  config?: { _as: 'props' } | C\n): ActionCreator<T> {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n\n  if (typeof config === 'function') {\n    return defineType(type, (...args: any[]) => ({\n      ...config(...args),\n      type,\n    }));\n  }\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type, () => ({ type }));\n    case 'props':\n      return defineType(type, (props: object) => ({\n        ...props,\n        type,\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\n\nexport function props<\n  P extends SafeProps,\n  SafeProps = NotAllowedInPropsCheck<P>\n>(): ActionCreatorProps<P> {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { _as: 'props', _p: undefined! };\n}\n\nexport function union<\n  C extends { [key: string]: ActionCreator<string, Creator> }\n>(creators: C): ReturnType<C[keyof C]> {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return undefined!;\n}\n\nfunction defineType<T extends string>(\n  type: T,\n  creator: Creator\n): ActionCreator<T> {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false,\n  }) as ActionCreator<T>;\n}\n", "export function capitalize<T extends string>(text: T): Capitalize<T> {\n  return (text.charAt(0).toUpperCase() + text.substring(1)) as Capitalize<T>;\n}\n\nexport function uncapitalize<T extends string>(text: T): Uncapitalize<T> {\n  return (text.charAt(0).toLowerCase() + text.substring(1)) as Uncapitalize<T>;\n}\n", "import { createAction, props } from './action_creator';\nimport {\n  ActionCreator,\n  ActionCreatorProps,\n  Creator,\n  FunctionWithParametersType,\n  NotAllowedCheck,\n  Action,\n} from './models';\nimport { capitalize, uncapitalize } from './helpers';\n\ntype Join<\n  Str extends string,\n  Separator extends string = ' '\n> = Str extends `${infer First}${Separator}${infer Rest}`\n  ? Join<`${First}${Rest}`, Separator>\n  : Str;\n\ntype CapitalizeWords<Str extends string> =\n  Str extends `${infer First} ${infer Rest}`\n    ? `${Capitalize<First>} ${CapitalizeWords<Rest>}`\n    : Capitalize<Str>;\n\ntype StringLiteralCheck<\n  Str extends string,\n  Name extends string\n> = string extends Str ? `${Name} must be a string literal type` : unknown;\n\ntype UniqueEventNameCheck<\n  EventNames extends string,\n  EventName extends string\n> = ActionName<EventName> extends ActionName<Exclude<EventNames, EventName>>\n  ? `${ActionName<EventName>} action is already defined`\n  : unknown;\n\ntype NotAllowedEventPropsCheck<\n  PropsCreator extends ActionCreatorProps<unknown> | Creator\n> = PropsCreator extends ActionCreatorProps<infer Props>\n  ? Props extends void\n    ? unknown\n    : NotAllowedCheck<Props & object>\n  : PropsCreator extends Creator<any, infer Result>\n  ? NotAllowedCheck<Result>\n  : unknown;\n\ntype EventCreator<\n  PropsCreator extends ActionCreatorProps<unknown> | Creator,\n  Type extends string\n> = PropsCreator extends ActionCreatorProps<infer Props>\n  ? void extends Props\n    ? ActionCreator<Type, () => Action<Type>>\n    : ActionCreator<\n        Type,\n        (props: Props & NotAllowedCheck<Props & object>) => Props & Action<Type>\n      >\n  : PropsCreator extends Creator<infer Props, infer Result>\n  ? FunctionWithParametersType<\n      Props,\n      Result & NotAllowedCheck<Result> & Action<Type>\n    > &\n      Action<Type>\n  : never;\n\ntype ActionName<EventName extends string> = Uncapitalize<\n  Join<CapitalizeWords<EventName>>\n>;\n\ninterface ActionGroupConfig<\n  Source extends string,\n  Events extends Record<string, ActionCreatorProps<unknown> | Creator>\n> {\n  source: Source & StringLiteralCheck<Source, 'source'>;\n  events: Events & {\n    [EventName in keyof Events]: StringLiteralCheck<\n      EventName & string,\n      'event name'\n    > &\n      UniqueEventNameCheck<keyof Events & string, EventName & string> &\n      NotAllowedEventPropsCheck<Events[EventName]>;\n  };\n}\n\ntype ActionGroup<\n  Source extends string,\n  Events extends Record<string, ActionCreatorProps<unknown> | Creator>\n> = {\n  [EventName in keyof Events as ActionName<EventName & string>]: EventCreator<\n    Events[EventName],\n    `[${Source}] ${EventName & string}`\n  >;\n};\n\n/**\n * @description\n * A function that creates a group of action creators with the same source.\n *\n * @param config An object that contains a source and dictionary of events.\n * An event is a key-value pair of an event name and event props.\n * @returns A dictionary of action creators.\n * The name of each action creator is created by camel casing the event name.\n * The type of each action is created using the \"[Source] Event Name\" pattern.\n *\n * @usageNotes\n *\n * ```ts\n * const authApiActions = createActionGroup({\n *   source: 'Auth API',\n *   events: {\n *     // defining events with payload using the `props` function\n *     'Login Success': props<{ userId: number; token: string }>(),\n *     'Login Failure': props<{ error: string }>(),\n *\n *     // defining an event without payload using the `emptyProps` function\n *     'Logout Success': emptyProps(),\n *\n *     // defining an event with payload using the props factory\n *     'Logout Failure': (error: Error) => ({ error }),\n *   },\n * });\n *\n * // action type: \"[Auth API] Login Success\"\n * authApiActions.loginSuccess({ userId: 10, token: 'ngrx' });\n *\n * // action type: \"[Auth API] Login Failure\"\n * authApiActions.loginFailure({ error: 'Login Failure!' });\n *\n * // action type: \"[Auth API] Logout Success\"\n * authApiActions.logoutSuccess();\n *\n * // action type: \"[Auth API] Logout Failure\";\n * authApiActions.logoutFailure(new Error('Logout Failure!'));\n * ```\n */\nexport function createActionGroup<\n  Source extends string,\n  Events extends Record<string, ActionCreatorProps<unknown> | Creator>\n>(config: ActionGroupConfig<Source, Events>): ActionGroup<Source, Events> {\n  const { source, events } = config;\n\n  return Object.keys(events).reduce(\n    (actionGroup, eventName) => ({\n      ...actionGroup,\n      [toActionName(eventName)]: createAction(\n        toActionType(source, eventName),\n        (events as any)[eventName]\n      ),\n    }),\n    {} as ActionGroup<Source, Events>\n  );\n}\n\nexport function emptyProps(): ActionCreatorProps<void> {\n  return props();\n}\n\nfunction toActionName<EventName extends string>(\n  eventName: EventName\n): ActionName<EventName> {\n  return eventName\n    .trim()\n    .split(' ')\n    .map((word, i) => (i === 0 ? uncapitalize(word) : capitalize(word)))\n    .join('') as ActionName<EventName>;\n}\n\nfunction toActionType<Source extends string, EventName extends string>(\n  source: Source,\n  eventName: EventName\n): `[${Source}] ${EventName}` {\n  return `[${source}] ${eventName}`;\n}\n", "import { Injectable, OnDestroy, Provider } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\nimport { Action } from './models';\n\nexport const INIT = '@ngrx/store/init' as const;\n\n@Injectable()\nexport class ActionsSubject\n  extends BehaviorSubject<Action>\n  implements OnDestroy\n{\n  constructor() {\n    super({ type: INIT });\n  }\n\n  override next(action: Action): void {\n    if (typeof action === 'function') {\n      throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n    } else if (typeof action === 'undefined') {\n      throw new TypeError(`Actions must be objects`);\n    } else if (typeof action.type === 'undefined') {\n      throw new TypeError(`Actions must have a type property`);\n    }\n    super.next(action);\n  }\n\n  override complete() {\n    /* noop */\n  }\n\n  ngOnDestroy() {\n    super.complete();\n  }\n}\n\nexport const ACTIONS_SUBJECT_PROVIDERS: Provider[] = [ActionsSubject];\n", "import { InjectionToken } from '@angular/core';\nimport { RuntimeChecks, MetaReducer } from './models';\n\nexport const _ROOT_STORE_GUARD = new InjectionToken<void>(\n  '@ngrx/store Internal Root Guard'\n);\nexport const _INITIAL_STATE = new InjectionToken(\n  '@ngrx/store Internal Initial State'\n);\nexport const INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nexport const REDUCER_FACTORY = new InjectionToken(\n  '@ngrx/store Reducer Factory'\n);\nexport const _REDUCER_FACTORY = new InjectionToken(\n  '@ngrx/store Internal Reducer Factory Provider'\n);\nexport const INITIAL_REDUCERS = new InjectionToken(\n  '@ngrx/store Initial Reducers'\n);\nexport const _INITIAL_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Initial Reducers'\n);\nexport const STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nexport const _STORE_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Store Reducers'\n);\nexport const _FEATURE_REDUCERS = new InjectionToken(\n  '@ngrx/store Internal Feature Reducers'\n);\n\nexport const _FEATURE_CONFIGS = new InjectionToken(\n  '@ngrx/store Internal Feature Configs'\n);\n\nexport const _STORE_FEATURES = new InjectionToken(\n  '@ngrx/store Internal Store Features'\n);\n\nexport const _FEATURE_REDUCERS_TOKEN = new InjectionToken(\n  '@ngrx/store Internal Feature Reducers Token'\n);\nexport const FEATURE_REDUCERS = new InjectionToken(\n  '@ngrx/store Feature Reducers'\n);\n\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\nexport const USER_PROVIDED_META_REDUCERS = new InjectionToken<MetaReducer[]>(\n  '@ngrx/store User Provided Meta Reducers'\n);\n\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\nexport const META_REDUCERS = new InjectionToken<MetaReducer[]>(\n  '@ngrx/store Meta Reducers'\n);\n\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\nexport const _RESOLVED_META_REDUCERS = new InjectionToken<MetaReducer>(\n  '@ngrx/store Internal Resolved Meta Reducers'\n);\n\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\nexport const USER_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store User Runtime Checks Config'\n);\n\n/**\n * Runtime checks defined by the user via forRoot()\n */\nexport const _USER_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store Internal User Runtime Checks Config'\n);\n\n/**\n * Runtime checks currently in use\n */\nexport const ACTIVE_RUNTIME_CHECKS = new InjectionToken<RuntimeChecks>(\n  '@ngrx/store Internal Runtime Checks'\n);\n\nexport const _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken<void>(\n  '@ngrx/store Check if Action types are unique'\n);\n\n/**\n * InjectionToken that registers the global Store.\n * Mainly used to provide a hook that can be injected\n * to ensure the root state is loaded before something\n * that depends on it.\n */\nexport const ROOT_STORE_PROVIDER = new InjectionToken<void>(\n  '@ngrx/store Root Store Provider'\n);\n\n/**\n * InjectionToken that registers feature states.\n * Mainly used to provide a hook that can be injected\n * to ensure feature state is loaded before something\n * that depends on it.\n */\nexport const FEATURE_STATE_PROVIDER = new InjectionToken<void>(\n  '@ngrx/store Feature State Provider'\n);\n", "import {\n  Action,\n  ActionReducer,\n  ActionReducerFactory,\n  ActionReducerMap,\n  MetaReducer,\n  InitialState,\n} from './models';\n\nexport function combineReducers<T, V extends Action = Action>(\n  reducers: ActionReducerMap<T, V>,\n  initialState?: Partial<T>\n): ActionReducer<T, V>;\n/**\n * @description\n * Combines reducers for individual features into a single reducer.\n *\n * You can use this function to delegate handling of state transitions to multiple reducers, each acting on their\n * own sub-state within the root state.\n *\n * @param reducers An object mapping keys of the root state to their corresponding feature reducer.\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * **Example combining two feature reducers into one \"root\" reducer**\n *\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * });\n * ```\n *\n * You can also override the initial states of the sub-features:\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * }, {\n *   featureA: { counterA: 13 },\n *   featureB: { counterB: 37 }\n * });\n * ```\n */\nexport function combineReducers(\n  reducers: any,\n  initialState: any = {}\n): ActionReducer<any, Action> {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers: any = {};\n\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  return function combination(state, action) {\n    state = state === undefined ? initialState : state;\n    let hasChanged = false;\n    const nextState: any = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer: any = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\nexport function omit<T extends { [key: string]: any }>(\n  object: T,\n  keyToRemove: keyof T\n): Partial<T> {\n  return Object.keys(object)\n    .filter((key) => key !== keyToRemove)\n    .reduce((result, key) => Object.assign(result, { [key]: object[key] }), {});\n}\n\nexport function compose<A>(): (i: A) => A;\nexport function compose<A, B>(b: (i: A) => B): (i: A) => B;\nexport function compose<A, B, C>(c: (i: B) => C, b: (i: A) => B): (i: A) => C;\nexport function compose<A, B, C, D>(\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => D;\nexport function compose<A, B, C, D, E>(\n  e: (i: D) => E,\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => E;\nexport function compose<A, B, C, D, E, F>(\n  f: (i: E) => F,\n  e: (i: D) => E,\n  d: (i: C) => D,\n  c: (i: B) => C,\n  b: (i: A) => B\n): (i: A) => F;\nexport function compose<A = any, F = any>(...functions: any[]): (i: A) => F;\nexport function compose(...functions: any[]) {\n  return function (arg: any) {\n    if (functions.length === 0) {\n      return arg;\n    }\n\n    const last = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n\n    return rest.reduceRight((composed, fn) => fn(composed), last(arg));\n  };\n}\n\nexport function createReducerFactory<T, V extends Action = Action>(\n  reducerFactory: ActionReducerFactory<T, V>,\n  metaReducers?: MetaReducer<T, V>[]\n): ActionReducerFactory<T, V> {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    (reducerFactory as any) = compose.apply(null, [\n      ...metaReducers,\n      reducerFactory,\n    ]);\n  }\n\n  return (reducers: ActionReducerMap<T, V>, initialState?: InitialState<T>) => {\n    const reducer = reducerFactory(reducers);\n    return (state: T | undefined, action: V) => {\n      state = state === undefined ? (initialState as T) : state;\n      return reducer(state, action);\n    };\n  };\n}\n\nexport function createFeatureReducerFactory<T, V extends Action = Action>(\n  metaReducers?: MetaReducer<T, V>[]\n): (reducer: ActionReducer<T, V>, initialState?: T) => ActionReducer<T, V> {\n  const reducerFactory =\n    Array.isArray(metaReducers) && metaReducers.length > 0\n      ? compose<ActionReducer<T, V>>(...metaReducers)\n      : (r: ActionReducer<T, V>) => r;\n\n  return (reducer: ActionReducer<T, V>, initialState?: T) => {\n    reducer = reducerFactory(reducer);\n\n    return (state: T | undefined, action: V) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\n", "import { Inject, Injectable, OnDestroy, Provider } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { ActionsSubject } from './actions_subject';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerFactory,\n  ActionReducerMap,\n  StoreFeature,\n} from './models';\nimport { INITIAL_REDUCERS, INITIAL_STATE, REDUCER_FACTORY } from './tokens';\nimport {\n  createFeatureReducerFactory,\n  createReducerFactory,\n  omit,\n} from './utils';\n\nexport abstract class ReducerObservable extends Observable<\n  ActionReducer<any, any>\n> {}\nexport abstract class ReducerManagerDispatcher extends ActionsSubject {}\nexport const UPDATE = '@ngrx/store/update-reducers' as const;\n\n@Injectable()\nexport class ReducerManager\n  extends BehaviorSubject<ActionReducer<any, any>>\n  implements OnDestroy\n{\n  get currentReducers(): ActionReducerMap<any, any> {\n    return this.reducers;\n  }\n\n  constructor(\n    private dispatcher: ReducerManagerDispatcher,\n    @Inject(INITIAL_STATE) private initialState: any,\n    @Inject(INITIAL_REDUCERS) private reducers: ActionReducerMap<any, any>,\n    @Inject(REDUCER_FACTORY)\n    private reducerFactory: ActionReducerFactory<any, any>\n  ) {\n    super(reducerFactory(reducers, initialState));\n  }\n\n  addFeature(feature: StoreFeature<any, any>) {\n    this.addFeatures([feature]);\n  }\n\n  addFeatures(features: StoreFeature<any, any>[]) {\n    const reducers = features.reduce(\n      (\n        reducerDict,\n        { reducers, reducerFactory, metaReducers, initialState, key }\n      ) => {\n        const reducer =\n          typeof reducers === 'function'\n            ? createFeatureReducerFactory(metaReducers)(reducers, initialState)\n            : createReducerFactory(reducerFactory, metaReducers)(\n                reducers,\n                initialState\n              );\n\n        reducerDict[key] = reducer;\n        return reducerDict;\n      },\n      {} as { [key: string]: ActionReducer<any, any> }\n    );\n\n    this.addReducers(reducers);\n  }\n\n  removeFeature(feature: StoreFeature<any, any>) {\n    this.removeFeatures([feature]);\n  }\n\n  removeFeatures(features: StoreFeature<any, any>[]) {\n    this.removeReducers(features.map((p) => p.key));\n  }\n\n  addReducer(key: string, reducer: ActionReducer<any, any>) {\n    this.addReducers({ [key]: reducer });\n  }\n\n  addReducers(reducers: { [key: string]: ActionReducer<any, any> }) {\n    this.reducers = { ...this.reducers, ...reducers };\n    this.updateReducers(Object.keys(reducers));\n  }\n\n  removeReducer(featureKey: string) {\n    this.removeReducers([featureKey]);\n  }\n\n  removeReducers(featureKeys: string[]) {\n    featureKeys.forEach((key) => {\n      this.reducers = omit(this.reducers, key) /*TODO(#823)*/ as any;\n    });\n    this.updateReducers(featureKeys);\n  }\n\n  private updateReducers(featureKeys: string[]) {\n    this.next(this.reducerFactory(this.reducers, this.initialState));\n    this.dispatcher.next(<Action>{\n      type: UPDATE,\n      features: featureKeys,\n    });\n  }\n\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n\nexport const REDUCER_MANAGER_PROVIDERS: Provider[] = [\n  ReducerManager,\n  { provide: ReducerObservable, useExisting: ReducerManager },\n  { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\n", "import { Injectable, OnDestroy, Provider } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { Action } from './models';\n\n@Injectable()\nexport class ScannedActionsSubject\n  extends Subject<Action>\n  implements OnDestroy\n{\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n\nexport const SCANNED_ACTIONS_SUBJECT_PROVIDERS: Provider[] = [\n  ScannedActionsSubject,\n];\n", "import { Inject, Injectable, OnDestroy, Provider, Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport {\n  BehaviorSubject,\n  Observable,\n  queueScheduler,\n  Subscription,\n} from 'rxjs';\nimport { observeOn, scan, withLatestFrom } from 'rxjs/operators';\n\nimport { ActionsSubject, INIT } from './actions_subject';\nimport { Action, ActionReducer } from './models';\nimport { ReducerObservable } from './reducer_manager';\nimport { ScannedActionsSubject } from './scanned_actions_subject';\nimport { INITIAL_STATE } from './tokens';\n\nexport abstract class StateObservable extends Observable<any> {\n  /**\n   * @internal\n   */\n  abstract readonly state: Signal<any>;\n}\n\n@Injectable()\nexport class State<T> extends BehaviorSubject<any> implements OnDestroy {\n  static readonly INIT = INIT;\n\n  private stateSubscription: Subscription;\n\n  /**\n   * @internal\n   */\n  public state: Signal<T>;\n\n  constructor(\n    actions$: ActionsSubject,\n    reducer$: ReducerObservable,\n    scannedActions: ScannedActionsSubject,\n    @Inject(INITIAL_STATE) initialState: any\n  ) {\n    super(initialState);\n\n    const actionsOnQueue$: Observable<Action> = actions$.pipe(\n      observeOn(queueScheduler)\n    );\n    const withLatestReducer$: Observable<[Action, ActionReducer<any, Action>]> =\n      actionsOnQueue$.pipe(withLatestFrom(reducer$));\n\n    const seed: StateActionPair<T> = { state: initialState };\n    const stateAndAction$: Observable<{\n      state: any;\n      action?: Action;\n    }> = withLatestReducer$.pipe(\n      scan<[Action, ActionReducer<T, Action>], StateActionPair<T>>(\n        reduceState,\n        seed\n      )\n    );\n\n    this.stateSubscription = stateAndAction$.subscribe(({ state, action }) => {\n      this.next(state);\n      scannedActions.next(action as Action);\n    });\n\n    this.state = toSignal(this, { manualCleanup: true, requireSync: true });\n  }\n\n  ngOnDestroy() {\n    this.stateSubscription.unsubscribe();\n    this.complete();\n  }\n}\n\nexport type StateActionPair<T, V extends Action = Action> = {\n  state: T | undefined;\n  action?: V;\n};\nexport function reduceState<T, V extends Action = Action>(\n  stateActionPair: StateActionPair<T, V> = { state: undefined },\n  [action, reducer]: [V, ActionReducer<T, V>]\n): StateActionPair<T, V> {\n  const { state } = stateActionPair;\n  return { state: reducer(state, action), action };\n}\n\nexport const STATE_PROVIDERS: Provider[] = [\n  State,\n  { provide: StateObservable, useExisting: State },\n];\n", "// disabled because we have lowercase generics for `select`\nimport { computed, Injectable, Provider, Signal } from '@angular/core';\nimport { Observable, Observer, Operator } from 'rxjs';\nimport { distinctUntilChanged, map, pluck } from 'rxjs/operators';\n\nimport { ActionsSubject } from './actions_subject';\nimport {\n  Action,\n  ActionReducer,\n  SelectSignalOptions,\n  FunctionIsNotAllowed,\n} from './models';\nimport { ReducerManager } from './reducer_manager';\nimport { StateObservable } from './state';\n\n@Injectable()\nexport class Store<T = object>\n  extends Observable<T>\n  implements Observer<Action>\n{\n  /**\n   * @internal\n   */\n  readonly state: Signal<T>;\n\n  constructor(\n    state$: StateObservable,\n    private actionsObserver: ActionsSubject,\n    private reducerManager: ReducerManager\n  ) {\n    super();\n\n    this.source = state$;\n    this.state = state$.state;\n  }\n\n  select<K>(mapFn: (state: T) => K): Observable<K>;\n  /**\n   * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n   */\n  select<K, Props = any>(\n    mapFn: (state: T, props: Props) => K,\n    props: Props\n  ): Observable<K>;\n  select<a extends keyof T>(key: a): Observable<T[a]>;\n  select<a extends keyof T, b extends keyof T[a]>(\n    key1: a,\n    key2: b\n  ): Observable<T[a][b]>;\n  select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(\n    key1: a,\n    key2: b,\n    key3: c\n  ): Observable<T[a][b][c]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c]\n  >(key1: a, key2: b, key3: c, key4: d): Observable<T[a][b][c][d]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d]\n  >(key1: a, key2: b, key3: c, key4: d, key5: e): Observable<T[a][b][c][d][e]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e]\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f\n  ): Observable<T[a][b][c][d][e][f]>;\n  select<\n    a extends keyof T,\n    b extends keyof T[a],\n    c extends keyof T[a][b],\n    d extends keyof T[a][b][c],\n    e extends keyof T[a][b][c][d],\n    f extends keyof T[a][b][c][d][e],\n    K = any\n  >(\n    key1: a,\n    key2: b,\n    key3: c,\n    key4: d,\n    key5: e,\n    key6: f,\n    ...paths: string[]\n  ): Observable<K>;\n  select<Props = any, K = any>(\n    pathOrMapFn: ((state: T, props?: Props) => K) | string,\n    ...paths: string[]\n  ): Observable<any> {\n    return (select as any).call(null, pathOrMapFn, ...paths)(this);\n  }\n\n  /**\n   * Returns a signal of the provided selector.\n   *\n   * @param selector selector function\n   * @param options select signal options\n   */\n  selectSignal<K>(\n    selector: (state: T) => K,\n    options?: SelectSignalOptions<K>\n  ): Signal<K> {\n    return computed(() => selector(this.state()), options);\n  }\n\n  override lift<R>(operator: Operator<T, R>): Store<R> {\n    const store = new Store<R>(this, this.actionsObserver, this.reducerManager);\n    store.operator = operator;\n\n    return store;\n  }\n\n  dispatch<V extends Action = Action>(\n    action: V &\n      FunctionIsNotAllowed<\n        V,\n        'Functions are not allowed to be dispatched. Did you forget to call the action creator function?'\n      >\n  ) {\n    this.actionsObserver.next(action);\n  }\n\n  next(action: Action) {\n    this.actionsObserver.next(action);\n  }\n\n  error(err: any) {\n    this.actionsObserver.error(err);\n  }\n\n  complete() {\n    this.actionsObserver.complete();\n  }\n\n  addReducer<State, Actions extends Action = Action>(\n    key: string,\n    reducer: ActionReducer<State, Actions>\n  ) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n\n  removeReducer<Key extends Extract<keyof T, string>>(key: Key) {\n    this.reducerManager.removeReducer(key);\n  }\n}\n\nexport const STORE_PROVIDERS: Provider[] = [Store];\n\nexport function select<T, K>(\n  mapFn: (state: T) => K\n): (source$: Observable<T>) => Observable<K>;\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function select<T, Props, K>(\n  mapFn: (state: T, props: Props) => K,\n  props: Props\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, a extends keyof T>(\n  key: a\n): (source$: Observable<T>) => Observable<T[a]>;\nexport function select<T, a extends keyof T, b extends keyof T[a]>(\n  key1: a,\n  key2: b\n): (source$: Observable<T>) => Observable<T[a][b]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b]\n>(\n  key1: a,\n  key2: b,\n  key3: c\n): (source$: Observable<T>) => Observable<T[a][b][c]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d\n): (source$: Observable<T>) => Observable<T[a][b][c][d]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e]\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;\nexport function select<\n  T,\n  a extends keyof T,\n  b extends keyof T[a],\n  c extends keyof T[a][b],\n  d extends keyof T[a][b][c],\n  e extends keyof T[a][b][c][d],\n  f extends keyof T[a][b][c][d][e],\n  K = any\n>(\n  key1: a,\n  key2: b,\n  key3: c,\n  key4: d,\n  key5: e,\n  key6: f,\n  ...paths: string[]\n): (source$: Observable<T>) => Observable<K>;\nexport function select<T, Props, K>(\n  pathOrMapFn: ((state: T, props?: Props) => any) | string,\n  propsOrPath?: Props | string,\n  ...paths: string[]\n) {\n  return function selectOperator(source$: Observable<T>): Observable<K> {\n    let mapped$: Observable<any>;\n\n    if (typeof pathOrMapFn === 'string') {\n      const pathSlices = [<string>propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(\n        map((source) => pathOrMapFn(source, <Props>propsOrPath))\n      );\n    } else {\n      throw new TypeError(\n        `Unexpected type '${typeof pathOrMapFn}' in select operator,` +\n          ` expected 'string' or 'function'`\n      );\n    }\n\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\n", "export const RUNTIME_CHECK_URL =\n  'https://ngrx.io/guide/store/configuration/runtime-checks';\n\nexport function isUndefined(target: any): target is undefined {\n  return target === undefined;\n}\n\nexport function isNull(target: any): target is null {\n  return target === null;\n}\n\nexport function isArray(target: any): target is Array<any> {\n  return Array.isArray(target);\n}\n\nexport function isString(target: any): target is string {\n  return typeof target === 'string';\n}\n\nexport function isBoolean(target: any): target is boolean {\n  return typeof target === 'boolean';\n}\n\nexport function isNumber(target: any): target is number {\n  return typeof target === 'number';\n}\n\nexport function isObjectLike(target: any): target is object {\n  return typeof target === 'object' && target !== null;\n}\n\nexport function isObject(target: any): target is object {\n  return isObjectLike(target) && !isArray(target);\n}\n\nexport function isPlainObject(target: any): target is object {\n  if (!isObject(target)) {\n    return false;\n  }\n\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\n\nexport function isFunction(target: any): target is () => void {\n  return typeof target === 'function';\n}\n\nexport function isComponent(target: any) {\n  return isFunction(target) && target.hasOwnProperty('ɵcmp');\n}\n\nexport function hasOwnProperty(target: object, propertyName: string): boolean {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n", "let _ngrxMockEnvironment = false;\nexport function setNgrxMockEnvironment(value: boolean): void {\n  _ngrxMockEnvironment = value;\n}\nexport function isNgrxMockEnvironment(): boolean {\n  return _ngrxMockEnvironment;\n}\n", "import { Selector, SelectorWithProps } from './models';\nimport { isDevMode } from '@angular/core';\nimport { isNgrxMockEnvironment } from './flags';\n\nexport type AnyFn = (...args: any[]) => any;\n\nexport type MemoizedProjection = {\n  memoized: AnyFn;\n  reset: () => void;\n  setResult: (result?: any) => void;\n  clearResult: () => void;\n};\n\nexport type MemoizeFn = (t: AnyFn) => MemoizedProjection;\n\nexport type ComparatorFn = (a: any, b: any) => boolean;\n\nexport type DefaultProjectorFn<T> = (...args: any[]) => T;\n\nexport interface MemoizedSelector<\n  State,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> extends Selector<State, Result> {\n  release(): void;\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see the {@link https://ngrx.io/guide/migration/v12#ngrxstore migration guide}\n */\nexport interface MemoizedSelectorWithProps<\n  State,\n  Props,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> extends SelectorWithProps<State, Props, Result> {\n  release(): void;\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n\nexport function isEqualCheck(a: any, b: any): boolean {\n  return a === b;\n}\n\nfunction isArgumentsChanged(\n  args: IArguments,\n  lastArguments: IArguments,\n  comparator: ComparatorFn\n) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function resultMemoize(\n  projectionFn: AnyFn,\n  isResultEqual: ComparatorFn\n) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\n\nexport function defaultMemoize(\n  projectionFn: AnyFn,\n  isArgumentsEqual = isEqualCheck,\n  isResultEqual = isEqualCheck\n): MemoizedProjection {\n  let lastArguments: null | IArguments = null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, , , , ,\n  let lastResult: any = null;\n  let overrideResult: any;\n\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n\n  function setResult(result: any = undefined) {\n    overrideResult = { result };\n  }\n\n  function clearResult() {\n    overrideResult = undefined;\n  }\n\n  /* eslint-disable prefer-rest-params, prefer-spread */\n\n  // disabled because of the use of `arguments`\n  function memoized(): any {\n    if (overrideResult !== undefined) {\n      return overrideResult.result;\n    }\n\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments as any);\n      lastArguments = arguments;\n      return lastResult;\n    }\n\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n\n    const newResult = projectionFn.apply(null, arguments as any);\n    lastArguments = arguments;\n\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n\n    lastResult = newResult;\n\n    return newResult;\n  }\n\n  return { memoized, reset, setResult, clearResult };\n}\n\nexport function createSelector<State, S1, Result>(\n  s1: Selector<State, S1>,\n  projector: (s1: S1) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  projector: (s1: S1, s2: S2) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  projector: (s1: S1, s2: S2, s3: S3) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, S4, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, S4, S5, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  s7: Selector<State, S7>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result\n): MemoizedSelector<State, Result, typeof projector>;\nexport function createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>(\n  s1: Selector<State, S1>,\n  s2: Selector<State, S2>,\n  s3: Selector<State, S3>,\n  s4: Selector<State, S4>,\n  s5: Selector<State, S5>,\n  s6: Selector<State, S6>,\n  s7: Selector<State, S7>,\n  s8: Selector<State, S8>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8\n  ) => Result\n): MemoizedSelector<State, Result, typeof projector>;\n\nexport function createSelector<\n  Selectors extends Record<string, Selector<State, unknown>>,\n  State = Selectors extends Record<string, Selector<infer S, unknown>>\n    ? S\n    : never,\n  Result extends Record<string, unknown> = {\n    [Key in keyof Selectors]: Selectors[Key] extends Selector<State, infer R>\n      ? R\n      : never;\n  }\n>(selectors: Selectors): MemoizedSelector<State, Result, never>;\n\nexport function createSelector<State, Slices extends unknown[], Result>(\n  ...args: [...slices: Selector<State, unknown>[], projector: unknown] &\n    [\n      ...slices: { [i in keyof Slices]: Selector<State, Slices[i]> },\n      projector: (...s: Slices) => Result\n    ]\n): MemoizedSelector<State, Result, (...s: Slices) => Result>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  Result\n>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  s7: SelectorWithProps<State, Props, S7>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  S8,\n  Result\n>(\n  s1: SelectorWithProps<State, Props, S1>,\n  s2: SelectorWithProps<State, Props, S2>,\n  s3: SelectorWithProps<State, Props, S3>,\n  s4: SelectorWithProps<State, Props, S4>,\n  s5: SelectorWithProps<State, Props, S5>,\n  s6: SelectorWithProps<State, Props, S6>,\n  s7: SelectorWithProps<State, Props, S7>,\n  s8: SelectorWithProps<State, Props, S8>,\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\nexport function createSelector<State, Slices extends unknown[], Result>(\n  selectors: Selector<State, unknown>[] &\n    [...{ [i in keyof Slices]: Selector<State, Slices[i]> }],\n  projector: (...s: Slices) => Result\n): MemoizedSelector<State, Result, (...s: Slices) => Result>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, Result>(\n  selectors: [SelectorWithProps<State, Props, S1>],\n  projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>\n  ],\n  projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>\n  ],\n  projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  Result\n>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>,\n    SelectorWithProps<State, Props, S7>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelector<\n  State,\n  Props,\n  S1,\n  S2,\n  S3,\n  S4,\n  S5,\n  S6,\n  S7,\n  S8,\n  Result\n>(\n  selectors: [\n    SelectorWithProps<State, Props, S1>,\n    SelectorWithProps<State, Props, S2>,\n    SelectorWithProps<State, Props, S3>,\n    SelectorWithProps<State, Props, S4>,\n    SelectorWithProps<State, Props, S5>,\n    SelectorWithProps<State, Props, S6>,\n    SelectorWithProps<State, Props, S7>,\n    SelectorWithProps<State, Props, S8>\n  ],\n  projector: (\n    s1: S1,\n    s2: S2,\n    s3: S3,\n    s4: S4,\n    s5: S5,\n    s6: S6,\n    s7: S7,\n    s8: S8,\n    props: Props\n  ) => Result\n): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;\n\nexport function createSelector(\n  ...input: any[]\n): MemoizedSelector<any, any> | MemoizedSelectorWithProps<any, any, any> {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\n\nexport function defaultStateFn(\n  state: any,\n  selectors: Selector<any, any>[] | SelectorWithProps<any, any, any>[],\n  props: any,\n  memoizedProjector: MemoizedProjection\n): any {\n  if (props === undefined) {\n    const args = (<Selector<any, any>[]>selectors).map((fn) => fn(state));\n    return memoizedProjector.memoized.apply(null, args);\n  }\n\n  const args = (<SelectorWithProps<any, any, any>[]>selectors).map((fn) =>\n    fn(state, props)\n  );\n  return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n\nexport type SelectorFactoryConfig<T = any, V = any> = {\n  stateFn: (\n    state: T,\n    selectors: Selector<any, any>[],\n    props: any,\n    memoizedProjector: MemoizedProjection\n  ) => V;\n};\n\nexport function createSelectorFactory<T = any, V = any>(\n  memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelector<T, V>;\nexport function createSelectorFactory<T = any, V = any>(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelector<T, V>;\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelectorFactory<T = any, Props = any, V = any>(\n  memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;\n/**\n * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\n */\nexport function createSelectorFactory<T = any, Props = any, V = any>(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;\n/**\n *\n * @param memoize The function used to memoize selectors\n * @param options Config Object that may include a `stateFn` function defining how to return the selector's value, given the entire `Store`'s state, parent `Selector`s, `Props`, and a `MemoizedProjection`\n *\n * @usageNotes\n *\n * **Creating a Selector Factory Where Array Order Does Not Matter**\n *\n * ```ts\n * function removeMatch(arr: string[], target: string): string[] {\n *   const matchIndex = arr.indexOf(target);\n *   return [...arr.slice(0, matchIndex), ...arr.slice(matchIndex + 1)];\n * }\n *\n * function orderDoesNotMatterComparer(a: any, b: any): boolean {\n *   if (!Array.isArray(a) || !Array.isArray(b)) {\n *     return a === b;\n *   }\n *   if (a.length !== b.length) {\n *     return false;\n *   }\n *   let tempB = [...b];\n *   function reduceToDetermineIfArraysContainSameContents(\n *     previousCallResult: boolean,\n *     arrayMember: any\n *   ): boolean {\n *     if (previousCallResult === false) {\n *       return false;\n *     }\n *     if (tempB.includes(arrayMember)) {\n *       tempB = removeMatch(tempB, arrayMember);\n *       return true;\n *     }\n *     return false;\n *   }\n *   return a.reduce(reduceToDetermineIfArraysContainSameContents, true);\n * }\n *\n * export const createOrderDoesNotMatterSelector = createSelectorFactory(\n *   (projectionFun) => defaultMemoize(\n *     projectionFun,\n *     orderDoesNotMatterComparer,\n *     orderDoesNotMatterComparer\n *   )\n * );\n * ```\n *\n * **Creating an Alternative Memoization Strategy**\n *\n * ```ts\n * function serialize(x: any): string {\n *   return JSON.stringify(x);\n * }\n *\n * export const createFullHistorySelector = createSelectorFactory(\n *  (projectionFunction) => {\n *    const cache = {};\n *\n *    function memoized() {\n *      const serializedArguments = serialize(...arguments);\n *       if (cache[serializedArguments] != null) {\n *         cache[serializedArguments] = projectionFunction.apply(null, arguments);\n *       }\n *       return cache[serializedArguments];\n *     }\n *     return {\n *       memoized,\n *       reset: () => {},\n *       setResult: () => {},\n *       clearResult: () => {},\n *     };\n *   }\n * );\n * ```\n */\nexport function createSelectorFactory(\n  memoize: MemoizeFn,\n  options: SelectorFactoryConfig<any, any> = {\n    stateFn: defaultStateFn,\n  }\n) {\n  return function (\n    ...input: any[]\n  ): MemoizedSelector<any, any> | MemoizedSelectorWithProps<any, any, any> {\n    let args = input;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {\n      args = extractArgsFromSelectorsDictionary(args[0]);\n    }\n\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter(\n      (selector: any) =>\n        selector.release && typeof selector.release === 'function'\n    );\n\n    const memoizedProjector = memoize(function (...selectors: any[]) {\n      return projector.apply(null, selectors);\n    });\n\n    const memoizedState = defaultMemoize(function (state: any, props: any) {\n      return options.stateFn.apply(null, [\n        state,\n        selectors,\n        props,\n        memoizedProjector,\n      ]);\n    });\n\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n\n      memoizedSelectors.forEach((selector) => selector.release());\n    }\n\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult,\n    });\n  };\n}\n\nexport function createFeatureSelector<T>(\n  featureName: string\n): MemoizedSelector<object, T>;\n/**\n * @deprecated  Feature selectors with a root state are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/3179 Github Issue}\n */\nexport function createFeatureSelector<T, V>(\n  featureName: keyof T\n): MemoizedSelector<T, V>;\nexport function createFeatureSelector(\n  featureName: any\n): MemoizedSelector<any, any> {\n  return createSelector(\n    (state: any) => {\n      const featureState = state[featureName];\n      if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n        console.warn(\n          `@ngrx/store: The feature name \"${featureName}\" does ` +\n            'not exist in the state, therefore createFeatureSelector ' +\n            'cannot access it.  Be sure it is imported in a loaded module ' +\n            `using StoreModule.forRoot('${featureName}', ...) or ` +\n            `StoreModule.forFeature('${featureName}', ...).  If the default ` +\n            'state is intended to be undefined, as is the case with router ' +\n            'state, this development-only warning message can be ignored.'\n        );\n      }\n      return featureState;\n    },\n    (featureState: any) => featureState\n  );\n}\n\nfunction isSelectorsDictionary(\n  selectors: unknown\n): selectors is Record<string, Selector<unknown, unknown>> {\n  return (\n    !!selectors &&\n    typeof selectors === 'object' &&\n    Object.values(selectors).every((selector) => typeof selector === 'function')\n  );\n}\n\nfunction extractArgsFromSelectorsDictionary(\n  selectorsDictionary: Record<string, Selector<unknown, unknown>>\n): [\n  ...selectors: Selector<unknown, unknown>[],\n  projector: (...selectorResults: unknown[]) => unknown\n] {\n  const selectors = Object.values(selectorsDictionary);\n  const resultKeys = Object.keys(selectorsDictionary);\n  const projector = (...selectorResults: unknown[]) =>\n    resultKeys.reduce(\n      (result, key, index) => ({\n        ...result,\n        [key]: selectorResults[index],\n      }),\n      {}\n    );\n\n  return [...selectors, projector];\n}\n", "import { capitalize } from './helpers';\nimport { ActionReducer, Prettify, Primitive, Selector } from './models';\nimport { isPlainObject } from './meta-reducers/utils';\nimport {\n  createFeatureSelector,\n  createSelector,\n  MemoizedSelector,\n} from './selector';\n\nexport interface FeatureConfig<FeatureName extends string, FeatureState> {\n  name: FeatureName;\n  reducer: ActionReducer<FeatureState>;\n}\n\ntype Feature<FeatureName extends string, FeatureState> = FeatureConfig<\n  FeatureName,\n  FeatureState\n> &\n  BaseSelectors<FeatureName, FeatureState>;\n\ntype FeatureWithExtraSelectors<\n  FeatureName extends string,\n  FeatureState,\n  ExtraSelectors extends SelectorsDictionary\n> = string extends keyof ExtraSelectors\n  ? Feature<FeatureName, FeatureState>\n  : Omit<Feature<FeatureName, FeatureState>, keyof ExtraSelectors> &\n      ExtraSelectors;\n\ntype FeatureSelector<FeatureName extends string, FeatureState> = {\n  [K in FeatureName as `select${Capitalize<K>}State`]: MemoizedSelector<\n    Record<string, any>,\n    FeatureState,\n    (featureState: FeatureState) => FeatureState\n  >;\n};\n\ntype NestedSelectors<FeatureState> = FeatureState extends\n  | Primitive\n  | unknown[]\n  | Date\n  ? {}\n  : {\n      [K in keyof FeatureState &\n        string as `select${Capitalize<K>}`]: MemoizedSelector<\n        Record<string, any>,\n        FeatureState[K],\n        (featureState: FeatureState) => FeatureState[K]\n      >;\n    };\n\ntype BaseSelectors<FeatureName extends string, FeatureState> = FeatureSelector<\n  FeatureName,\n  FeatureState\n> &\n  NestedSelectors<FeatureState>;\n\ntype SelectorsDictionary = Record<\n  string,\n  | Selector<Record<string, any>, unknown>\n  | ((...args: any[]) => Selector<Record<string, any>, unknown>)\n>;\n\ntype ExtraSelectorsFactory<\n  FeatureName extends string,\n  FeatureState,\n  ExtraSelectors extends SelectorsDictionary\n> = (baseSelectors: BaseSelectors<FeatureName, FeatureState>) => ExtraSelectors;\n\ntype NotAllowedFeatureStateCheck<FeatureState> =\n  FeatureState extends Required<FeatureState>\n    ? unknown\n    : 'optional properties are not allowed in the feature state';\n\n/**\n * Creates a feature object with extra selectors.\n *\n * @param featureConfig An object that contains a feature name, a feature\n * reducer, and extra selectors factory.\n * @returns An object that contains a feature name, a feature reducer,\n * a feature selector, a selector for each feature state property, and\n * extra selectors.\n */\nexport function createFeature<\n  FeatureName extends string,\n  FeatureState,\n  ExtraSelectors extends SelectorsDictionary\n>(\n  featureConfig: FeatureConfig<FeatureName, FeatureState> & {\n    extraSelectors: ExtraSelectorsFactory<\n      FeatureName,\n      FeatureState,\n      ExtraSelectors\n    >;\n  } & NotAllowedFeatureStateCheck<FeatureState>\n): Prettify<\n  FeatureWithExtraSelectors<FeatureName, FeatureState, ExtraSelectors>\n>;\n/**\n * Creates a feature object.\n *\n * @param featureConfig An object that contains a feature name and a feature\n * reducer.\n * @returns An object that contains a feature name, a feature reducer,\n * a feature selector, and a selector for each feature state property.\n */\nexport function createFeature<FeatureName extends string, FeatureState>(\n  featureConfig: FeatureConfig<FeatureName, FeatureState> &\n    NotAllowedFeatureStateCheck<FeatureState>\n): Prettify<Feature<FeatureName, FeatureState>>;\n/**\n * @description\n * A function that accepts a feature name and a feature reducer, and creates\n * a feature selector and a selector for each feature state property.\n * This function also provides the ability to add extra selectors to\n * the feature object.\n *\n * @param featureConfig An object that contains a feature name and a feature\n * reducer as required, and extra selectors factory as an optional argument.\n * @returns An object that contains a feature name, a feature reducer,\n * a feature selector, a selector for each feature state property, and extra\n * selectors.\n *\n * @usageNotes\n *\n * ```ts\n * interface ProductsState {\n *   products: Product[];\n *   selectedId: string | null;\n * }\n *\n * const initialState: ProductsState = {\n *   products: [],\n *   selectedId: null,\n * };\n *\n * const productsFeature = createFeature({\n *   name: 'products',\n *   reducer: createReducer(\n *     initialState,\n *     on(ProductsApiActions.loadSuccess(state, { products }) => ({\n *       ...state,\n *       products,\n *     }),\n *   ),\n * });\n *\n * const {\n *   name,\n *   reducer,\n *   // feature selector\n *   selectProductsState, // type: MemoizedSelector<Record<string, any>, ProductsState>\n *   // feature state properties selectors\n *   selectProducts, // type: MemoizedSelector<Record<string, any>, Product[]>\n *   selectSelectedId, // type: MemoizedSelector<Record<string, any>, string | null>\n * } = productsFeature;\n * ```\n *\n * **Creating Feature with Extra Selectors**\n *\n * ```ts\n * type CallState = 'init' | 'loading' | 'loaded' | { error: string };\n *\n * interface State extends EntityState<Product> {\n *   callState: CallState;\n * }\n *\n * const adapter = createEntityAdapter<Product>();\n * const initialState: State = adapter.getInitialState({\n *   callState: 'init',\n * });\n *\n * export const productsFeature = createFeature({\n *   name: 'products',\n *   reducer: createReducer(initialState),\n *   extraSelectors: ({ selectProductsState, selectCallState }) => ({\n *     ...adapter.getSelectors(selectProductsState),\n *     ...getCallStateSelectors(selectCallState)\n *   }),\n * });\n *\n * const {\n *   name,\n *   reducer,\n *   // feature selector\n *   selectProductsState,\n *   // feature state properties selectors\n *   selectIds,\n *   selectEntities,\n *   selectCallState,\n *   // selectors returned by `adapter.getSelectors`\n *   selectAll,\n *   selectTotal,\n *   // selectors returned by `getCallStateSelectors`\n *   selectIsLoading,\n *   selectIsLoaded,\n *   selectError,\n * } = productsFeature;\n * ```\n */\nexport function createFeature<\n  FeatureName extends string,\n  FeatureState,\n  ExtraSelectors extends SelectorsDictionary\n>(\n  featureConfig: FeatureConfig<FeatureName, FeatureState> & {\n    extraSelectors?: ExtraSelectorsFactory<\n      FeatureName,\n      FeatureState,\n      ExtraSelectors\n    >;\n  }\n): Feature<FeatureName, FeatureState> & ExtraSelectors {\n  const {\n    name,\n    reducer,\n    extraSelectors: extraSelectorsFactory,\n  } = featureConfig;\n\n  const featureSelector = createFeatureSelector<FeatureState>(name);\n  const nestedSelectors = createNestedSelectors(featureSelector, reducer);\n  const baseSelectors = {\n    [`select${capitalize(name)}State`]: featureSelector,\n    ...nestedSelectors,\n  } as BaseSelectors<FeatureName, FeatureState>;\n  const extraSelectors = extraSelectorsFactory\n    ? extraSelectorsFactory(baseSelectors)\n    : {};\n\n  return {\n    name,\n    reducer,\n    ...baseSelectors,\n    ...extraSelectors,\n  } as Feature<FeatureName, FeatureState> & ExtraSelectors;\n}\n\nfunction createNestedSelectors<FeatureState>(\n  featureSelector: MemoizedSelector<Record<string, any>, FeatureState>,\n  reducer: ActionReducer<FeatureState>\n): NestedSelectors<FeatureState> {\n  const initialState = getInitialState(reducer);\n  const nestedKeys = (\n    isPlainObject(initialState) ? Object.keys(initialState) : []\n  ) as Array<keyof FeatureState & string>;\n\n  return nestedKeys.reduce(\n    (nestedSelectors, nestedKey) => ({\n      ...nestedSelectors,\n      [`select${capitalize(nestedKey)}`]: createSelector(\n        featureSelector,\n        (parentState) => parentState?.[nestedKey]\n      ),\n    }),\n    {} as NestedSelectors<FeatureState>\n  );\n}\n\nfunction getInitialState<FeatureState>(\n  reducer: ActionReducer<FeatureState>\n): FeatureState {\n  return reducer(undefined, { type: '@ngrx/feature/init' });\n}\n", "import { inject, InjectionToken } from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerMap,\n  ActionReducerFactory,\n  StoreFeature,\n  InitialState,\n  MetaReducer,\n  RuntimeChecks,\n} from './models';\nimport { combineReducers } from './utils';\nimport { Store } from './store';\n\nexport interface StoreConfig<T, V extends Action = Action> {\n  initialState?: InitialState<T>;\n  reducerFactory?: ActionReducerFactory<T, V>;\n  metaReducers?: MetaReducer<{ [P in keyof T]: T[P] }, V>[];\n}\n\nexport interface RootStoreConfig<T, V extends Action = Action>\n  extends StoreConfig<T, V> {\n  runtimeChecks?: Partial<RuntimeChecks>;\n}\n\n/**\n * An object with the name and the reducer for the feature.\n */\nexport interface FeatureSlice<T, V extends Action = Action> {\n  name: string;\n  reducer: ActionReducer<T, V>;\n}\n\nexport function _createStoreReducers<T, V extends Action = Action>(\n  reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>\n): ActionReducerMap<T, V> {\n  return reducers instanceof InjectionToken ? inject(reducers) : reducers;\n}\n\nexport function _createFeatureStore<T, V extends Action = Action>(\n  configs: StoreConfig<T, V>[] | InjectionToken<StoreConfig<T, V>>[],\n  featureStores: StoreFeature<T, V>[]\n) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = inject(configs[index] as InjectionToken<StoreConfig<T, V>>);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory\n          ? conf.reducerFactory\n          : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState,\n      };\n    }\n    return feat;\n  });\n}\n\nexport function _createFeatureReducers<T, V extends Action = Action>(\n  reducerCollection: Array<\n    ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>\n  >\n): ActionReducerMap<T, V>[] {\n  return reducerCollection.map((reducer) => {\n    return reducer instanceof InjectionToken ? inject(reducer) : reducer;\n  });\n}\n\nexport function _initialStateFactory(initialState: any): any {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n\n  return initialState;\n}\n\nexport function _concatMetaReducers(\n  metaReducers: MetaReducer[],\n  userProvidedMetaReducers: MetaReducer[]\n): MetaReducer[] {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\n\nexport function _provideForRootGuard(): unknown {\n  const store = inject(Store, { optional: true, skipSelf: true });\n  if (store) {\n    throw new TypeError(\n      `The root Store has been provided more than once. Feature modules should provide feature states instead.`\n    );\n  }\n  return 'guarded';\n}\n", "import { ActionReducer, Action } from '../models';\nimport { isFunction, hasOwnProperty, isObjectLike } from './utils';\n\nexport function immutabilityCheckMetaReducer(\n  reducer: ActionReducer<any, any>,\n  checks: { action: (action: Action) => boolean; state: () => boolean }\n): ActionReducer<any, any> {\n  return function (state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n\n    const nextState = reducer(state, act);\n\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\n\nfunction freeze(target: any) {\n  Object.freeze(target);\n\n  const targetIsFunction = isFunction(target);\n\n  Object.getOwnPropertyNames(target).forEach((prop) => {\n    // Ignore Ivy properties, ref: https://github.com/ngrx/platform/issues/2109#issuecomment-582689060\n    if (prop.startsWith('ɵ')) {\n      return;\n    }\n\n    if (\n      hasOwnProperty(target, prop) &&\n      (targetIsFunction\n        ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'\n        : true)\n    ) {\n      const propValue = target[prop];\n\n      if (\n        (isObjectLike(propValue) || isFunction(propValue)) &&\n        !Object.isFrozen(propValue)\n      ) {\n        freeze(propValue);\n      }\n    }\n  });\n\n  return target;\n}\n", "import { ActionReducer, Action } from '../models';\nimport {\n  isPlainObject,\n  isUndefined,\n  isNull,\n  isNumber,\n  isBoolean,\n  isString,\n  isArray,\n  RUNTIME_CHECK_URL,\n  isComponent,\n} from './utils';\n\nexport function serializationCheckMetaReducer(\n  reducer: ActionReducer<any, any>,\n  checks: { action: (action: Action) => boolean; state: () => boolean }\n): ActionReducer<any, any> {\n  return function (state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, 'action');\n    }\n\n    const nextState = reducer(state, action);\n\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, 'state');\n    }\n\n    return nextState;\n  };\n}\n\nfunction getUnserializable(\n  target?: any,\n  path: string[] = []\n): false | { path: string[]; value: any } {\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target,\n    };\n  }\n\n  const keys = Object.keys(target);\n  return keys.reduce<false | { path: string[]; value: any }>((result, key) => {\n    if (result) {\n      return result;\n    }\n\n    const value = (target as any)[key];\n\n    // Ignore Ivy components\n    if (isComponent(value)) {\n      return result;\n    }\n\n    if (\n      isUndefined(value) ||\n      isNull(value) ||\n      isNumber(value) ||\n      isBoolean(value) ||\n      isString(value) ||\n      isArray(value)\n    ) {\n      return false;\n    }\n\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n\n    return {\n      path: [...path, key],\n      value,\n    };\n  }, false);\n}\n\nfunction throwIfUnserializable(\n  unserializable: false | { path: string[]; value: any },\n  context: 'state' | 'action'\n) {\n  if (unserializable === false) {\n    return;\n  }\n\n  const unserializablePath = unserializable.path.join('.');\n  const error: any = new Error(\n    `Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`\n  );\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\n", "import * as ngCore from '@angular/core';\nimport { Action, ActionReducer } from '../models';\nimport { RUNTIME_CHECK_URL } from './utils';\n\nexport function inNgZoneAssertMetaReducer(\n  reducer: ActionReducer<any, Action>,\n  checks: { action: (action: Action) => boolean }\n) {\n  return function (state: any, action: Action) {\n    if (checks.action(action) && !ngCore.NgZone.isInAngularZone()) {\n      throw new Error(\n        `Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`\n      );\n    }\n    return reducer(state, action);\n  };\n}\n", "import { isDevMode, Provider } from '@angular/core';\nimport {\n  serializationCheckMetaReducer,\n  immutabilityCheckMetaReducer,\n  inNgZoneAssertMetaReducer,\n} from './meta-reducers';\nimport { RuntimeChecks, MetaReducer, Action } from './models';\nimport {\n  _USER_RUNTIME_CHECKS,\n  ACTIVE_RUNTIME_CHECKS,\n  META_REDUCERS,\n  USER_RUNTIME_CHECKS,\n  _ACTION_TYPE_UNIQUENESS_CHECK,\n} from './tokens';\nimport { REGISTERED_ACTION_TYPES } from './globals';\nimport { RUNTIME_CHECK_URL } from './meta-reducers/utils';\n\nexport function createActiveRuntimeChecks(\n  runtimeChecks?: Partial<RuntimeChecks>\n): RuntimeChecks {\n  if (isDevMode()) {\n    return {\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false,\n      ...runtimeChecks,\n    };\n  }\n\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false,\n  };\n}\n\nexport function createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionSerializability || strictStateSerializability\n      ? serializationCheckMetaReducer(reducer, {\n          action: (action) =>\n            strictActionSerializability && !ignoreNgrxAction(action),\n          state: () => strictStateSerializability,\n        })\n      : reducer;\n}\n\nexport function createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionImmutability || strictStateImmutability\n      ? immutabilityCheckMetaReducer(reducer, {\n          action: (action) =>\n            strictActionImmutability && !ignoreNgrxAction(action),\n          state: () => strictStateImmutability,\n        })\n      : reducer;\n}\n\nfunction ignoreNgrxAction(action: Action) {\n  return action.type.startsWith('@ngrx');\n}\n\nexport function createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone,\n}: RuntimeChecks): MetaReducer {\n  return (reducer) =>\n    strictActionWithinNgZone\n      ? inNgZoneAssertMetaReducer(reducer, {\n          action: (action) =>\n            strictActionWithinNgZone && !ignoreNgrxAction(action),\n        })\n      : reducer;\n}\n\nexport function provideRuntimeChecks(\n  runtimeChecks?: Partial<RuntimeChecks>\n): Provider[] {\n  return [\n    {\n      provide: _USER_RUNTIME_CHECKS,\n      useValue: runtimeChecks,\n    },\n    {\n      provide: USER_RUNTIME_CHECKS,\n      useFactory: _runtimeChecksFactory,\n      deps: [_USER_RUNTIME_CHECKS],\n    },\n    {\n      provide: ACTIVE_RUNTIME_CHECKS,\n      deps: [USER_RUNTIME_CHECKS],\n      useFactory: createActiveRuntimeChecks,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createImmutabilityCheckMetaReducer,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createSerializationCheckMetaReducer,\n    },\n    {\n      provide: META_REDUCERS,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: createInNgZoneCheckMetaReducer,\n    },\n  ];\n}\n\nexport function checkForActionTypeUniqueness(): Provider[] {\n  return [\n    {\n      provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n      multi: true,\n      deps: [ACTIVE_RUNTIME_CHECKS],\n      useFactory: _actionTypeUniquenessCheck,\n    },\n  ];\n}\n\nexport function _runtimeChecksFactory(\n  runtimeChecks: RuntimeChecks\n): RuntimeChecks {\n  return runtimeChecks;\n}\n\nexport function _actionTypeUniquenessCheck(config: RuntimeChecks): void {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES)\n    .filter(([, registrations]) => registrations > 1)\n    .map(([type]) => type);\n\n  if (duplicates.length) {\n    throw new Error(\n      `Action types are registered more than once, ${duplicates\n        .map((type) => `\"${type}\"`)\n        .join(', ')}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`\n    );\n  }\n}\n", "import {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  Inject,\n  inject,\n  InjectionToken,\n  makeEnvironmentProviders,\n  Provider,\n} from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerMap,\n  StoreFeature,\n} from './models';\nimport { combineReducers, createReducerFactory } from './utils';\nimport {\n  _ACTION_TYPE_UNIQUENESS_CHECK,\n  _FEATURE_CONFIGS,\n  _FEATURE_REDUCERS,\n  _FEATURE_REDUCERS_TOKEN,\n  _INITIAL_REDUCERS,\n  _INITIAL_STATE,\n  _REDUCER_FACTORY,\n  _RESOLVED_META_REDUCERS,\n  _ROOT_STORE_GUARD,\n  _STORE_FEATURES,\n  _STORE_REDUCERS,\n  FEATURE_REDUCERS,\n  FEATURE_STATE_PROVIDER,\n  INITIAL_REDUCERS,\n  INITIAL_STATE,\n  META_REDUCERS,\n  REDUCER_FACTORY,\n  ROOT_STORE_PROVIDER,\n  STORE_FEATURES,\n  USER_PROVIDED_META_REDUCERS,\n} from './tokens';\nimport { ACTIONS_SUBJECT_PROVIDERS, ActionsSubject } from './actions_subject';\nimport {\n  REDUCER_MANAGER_PROVIDERS,\n  ReducerManager,\n  ReducerObservable,\n} from './reducer_manager';\nimport {\n  SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n  ScannedActionsSubject,\n} from './scanned_actions_subject';\nimport { STATE_PROVIDERS } from './state';\nimport { Store, STORE_PROVIDERS } from './store';\nimport {\n  checkForActionTypeUniqueness,\n  provideRuntimeChecks,\n} from './runtime_checks';\nimport {\n  _concatMetaReducers,\n  _createFeatureReducers,\n  _createFeatureStore,\n  _createStoreReducers,\n  _initialStateFactory,\n  _provideForRootGuard,\n  FeatureSlice,\n  RootStoreConfig,\n  StoreConfig,\n} from './store_config';\n\nexport function provideState<T, V extends Action = Action>(\n  featureName: string,\n  reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n  config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n): EnvironmentProviders;\nexport function provideState<T, V extends Action = Action>(\n  featureName: string,\n  reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>,\n  config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n): EnvironmentProviders;\nexport function provideState<T, V extends Action = Action>(\n  slice: FeatureSlice<T, V>\n): EnvironmentProviders;\n/**\n * Provides additional slices of state in the Store.\n * These providers cannot be used at the component level.\n *\n * @usageNotes\n *\n * ### Providing Store Features\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideState('books', booksReducer)],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nexport function provideState<T, V extends Action = Action>(\n  featureNameOrSlice: string | FeatureSlice<T, V>,\n  reducers?:\n    | ActionReducerMap<T, V>\n    | InjectionToken<ActionReducerMap<T, V>>\n    | ActionReducer<T, V>\n    | InjectionToken<ActionReducer<T, V>>,\n  config: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>> = {}\n): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    ..._provideState(featureNameOrSlice, reducers, config),\n    ENVIRONMENT_STATE_PROVIDER,\n  ]);\n}\n\nexport function _provideStore<T, V extends Action = Action>(\n  reducers:\n    | ActionReducerMap<T, V>\n    | InjectionToken<ActionReducerMap<T, V>>\n    | Record<string, never> = {},\n  config: RootStoreConfig<T, V> = {}\n): Provider[] {\n  return [\n    {\n      provide: _ROOT_STORE_GUARD,\n      useFactory: _provideForRootGuard,\n    },\n    { provide: _INITIAL_STATE, useValue: config.initialState },\n    {\n      provide: INITIAL_STATE,\n      useFactory: _initialStateFactory,\n      deps: [_INITIAL_STATE],\n    },\n    { provide: _INITIAL_REDUCERS, useValue: reducers },\n    {\n      provide: _STORE_REDUCERS,\n      useExisting:\n        reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n    },\n    {\n      provide: INITIAL_REDUCERS,\n      deps: [_INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n      useFactory: _createStoreReducers,\n    },\n    {\n      provide: USER_PROVIDED_META_REDUCERS,\n      useValue: config.metaReducers ? config.metaReducers : [],\n    },\n    {\n      provide: _RESOLVED_META_REDUCERS,\n      deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n      useFactory: _concatMetaReducers,\n    },\n    {\n      provide: _REDUCER_FACTORY,\n      useValue: config.reducerFactory ? config.reducerFactory : combineReducers,\n    },\n    {\n      provide: REDUCER_FACTORY,\n      deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n      useFactory: createReducerFactory,\n    },\n    ACTIONS_SUBJECT_PROVIDERS,\n    REDUCER_MANAGER_PROVIDERS,\n    SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n    STATE_PROVIDERS,\n    STORE_PROVIDERS,\n    provideRuntimeChecks(config.runtimeChecks),\n    checkForActionTypeUniqueness(),\n  ];\n}\n\nfunction rootStoreProviderFactory(): void {\n  inject(ActionsSubject);\n  inject(ReducerObservable);\n  inject(ScannedActionsSubject);\n  inject(Store);\n  inject(_ROOT_STORE_GUARD, { optional: true });\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, { optional: true });\n}\n\n/**\n * Environment Initializer used in the root\n * providers to initialize the Store\n */\nconst ENVIRONMENT_STORE_PROVIDER: Provider[] = [\n  { provide: ROOT_STORE_PROVIDER, useFactory: rootStoreProviderFactory },\n  {\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useFactory() {\n      return () => inject(ROOT_STORE_PROVIDER);\n    },\n  },\n];\n\n/**\n * Provides the global Store providers and initializes\n * the Store.\n * These providers cannot be used at the component level.\n *\n * @usageNotes\n *\n * ### Providing the Global Store\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideStore()],\n * });\n * ```\n */\nexport function provideStore<T, V extends Action = Action>(\n  reducers?: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n  config?: RootStoreConfig<T, V>\n): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    ..._provideStore(reducers, config),\n    ENVIRONMENT_STORE_PROVIDER,\n  ]);\n}\n\nfunction featureStateProviderFactory(): void {\n  inject(ROOT_STORE_PROVIDER);\n  const features = inject<StoreFeature<any, any>[]>(_STORE_FEATURES);\n  const featureReducers = inject<ActionReducerMap<any>[]>(FEATURE_REDUCERS);\n  const reducerManager = inject(ReducerManager);\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, { optional: true });\n\n  const feats = features.map((feature, index) => {\n    const featureReducerCollection = featureReducers.shift();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const reducers = featureReducerCollection! /*TODO(#823)*/[index];\n\n    return {\n      ...feature,\n      reducers,\n      initialState: _initialStateFactory(feature.initialState),\n    };\n  });\n\n  reducerManager.addFeatures(feats);\n}\n\n/**\n * Environment Initializer used in the feature\n * providers to register state features\n */\nconst ENVIRONMENT_STATE_PROVIDER: Provider[] = [\n  {\n    provide: FEATURE_STATE_PROVIDER,\n    useFactory: featureStateProviderFactory,\n  },\n  {\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useFactory() {\n      return () => inject(FEATURE_STATE_PROVIDER);\n    },\n  },\n];\n\nexport function _provideState<T, V extends Action = Action>(\n  featureNameOrSlice: string | FeatureSlice<T, V>,\n  reducers?:\n    | ActionReducerMap<T, V>\n    | InjectionToken<ActionReducerMap<T, V>>\n    | ActionReducer<T, V>\n    | InjectionToken<ActionReducer<T, V>>,\n  config: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>> = {}\n): Provider[] {\n  return [\n    {\n      provide: _FEATURE_CONFIGS,\n      multi: true,\n      useValue: featureNameOrSlice instanceof Object ? {} : config,\n    },\n    {\n      provide: STORE_FEATURES,\n      multi: true,\n      useValue: {\n        key:\n          featureNameOrSlice instanceof Object\n            ? featureNameOrSlice.name\n            : featureNameOrSlice,\n        reducerFactory:\n          !(config instanceof InjectionToken) && config.reducerFactory\n            ? config.reducerFactory\n            : combineReducers,\n        metaReducers:\n          !(config instanceof InjectionToken) && config.metaReducers\n            ? config.metaReducers\n            : [],\n        initialState:\n          !(config instanceof InjectionToken) && config.initialState\n            ? config.initialState\n            : undefined,\n      },\n    },\n    {\n      provide: _STORE_FEATURES,\n      deps: [_FEATURE_CONFIGS, STORE_FEATURES],\n      useFactory: _createFeatureStore,\n    },\n    {\n      provide: _FEATURE_REDUCERS,\n      multi: true,\n      useValue:\n        featureNameOrSlice instanceof Object\n          ? featureNameOrSlice.reducer\n          : reducers,\n    },\n    {\n      provide: _FEATURE_REDUCERS_TOKEN,\n      multi: true,\n      useExisting:\n        reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS,\n    },\n    {\n      provide: FEATURE_REDUCERS,\n      multi: true,\n      deps: [_FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n      useFactory: _createFeatureReducers,\n    },\n    checkForActionTypeUniqueness(),\n  ];\n}\n", "import {\n  Inject,\n  InjectionToken,\n  ModuleWithProviders,\n  NgModule,\n  OnDestroy,\n  Optional,\n} from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionReducerMap,\n  StoreFeature,\n} from './models';\nimport {\n  _ACTION_TYPE_UNIQUENESS_CHECK,\n  _ROOT_STORE_GUARD,\n  _STORE_FEATURES,\n  FEATURE_REDUCERS,\n} from './tokens';\nimport { ActionsSubject } from './actions_subject';\nimport { ReducerManager, ReducerObservable } from './reducer_manager';\nimport { ScannedActionsSubject } from './scanned_actions_subject';\nimport { Store } from './store';\nimport {\n  _initialStateFactory,\n  FeatureSlice,\n  RootStoreConfig,\n  StoreConfig,\n} from './store_config';\nimport { _provideState, _provideStore } from './provide_store';\n\n@NgModule({})\nexport class StoreRootModule {\n  constructor(\n    actions$: ActionsSubject,\n    reducer$: ReducerObservable,\n    scannedActions$: ScannedActionsSubject,\n    store: Store<any>,\n    @Optional()\n    @Inject(_ROOT_STORE_GUARD)\n    guard: any,\n    @Optional()\n    @Inject(_ACTION_TYPE_UNIQUENESS_CHECK)\n    actionCheck: any\n  ) {}\n}\n\n@NgModule({})\nexport class StoreFeatureModule implements OnDestroy {\n  constructor(\n    @Inject(_STORE_FEATURES) private features: StoreFeature<any, any>[],\n    @Inject(FEATURE_REDUCERS) private featureReducers: ActionReducerMap<any>[],\n    private reducerManager: ReducerManager,\n    root: StoreRootModule,\n    @Optional()\n    @Inject(_ACTION_TYPE_UNIQUENESS_CHECK)\n    actionCheck: any\n  ) {\n    const feats = features.map((feature, index) => {\n      const featureReducerCollection = featureReducers.shift();\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const reducers = featureReducerCollection! /*TODO(#823)*/[index];\n\n      return {\n        ...feature,\n        reducers,\n        initialState: _initialStateFactory(feature.initialState),\n      };\n    });\n\n    reducerManager.addFeatures(feats);\n  }\n\n  // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n  ngOnDestroy() {\n    this.reducerManager.removeFeatures(this.features);\n  }\n}\n\n@NgModule({})\nexport class StoreModule {\n  static forRoot<T, V extends Action = Action>(\n    reducers?: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n    config?: RootStoreConfig<T, V>\n  ): ModuleWithProviders<StoreRootModule> {\n    return {\n      ngModule: StoreRootModule,\n      providers: [..._provideStore(reducers, config)],\n    };\n  }\n\n  static forFeature<T, V extends Action = Action>(\n    featureName: string,\n    reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>,\n    config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature<T, V extends Action = Action>(\n    featureName: string,\n    reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>,\n    config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature<T, V extends Action = Action>(\n    slice: FeatureSlice<T, V>\n  ): ModuleWithProviders<StoreFeatureModule>;\n  static forFeature<T, V extends Action = Action>(\n    featureNameOrSlice: string | FeatureSlice<T, V>,\n    reducers?:\n      | ActionReducerMap<T, V>\n      | InjectionToken<ActionReducerMap<T, V>>\n      | ActionReducer<T, V>\n      | InjectionToken<ActionReducer<T, V>>,\n    config: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>> = {}\n  ): ModuleWithProviders<StoreFeatureModule> {\n    return {\n      ngModule: StoreFeatureModule,\n      providers: [..._provideState(featureNameOrSlice, reducers, config)],\n    };\n  }\n}\n", "import { ActionCreator, ActionReducer, ActionType, Action } from './models';\n\n// Goes over the array of ActionCreators, pulls the action type out of each one\n// and returns the array of these action types.\ntype ExtractActionTypes<Creators extends readonly ActionCreator[]> = {\n  [Key in keyof Creators]: Creators[Key] extends ActionCreator<infer T>\n    ? T\n    : never;\n};\n\n/**\n * Return type of the `on` fn.\n * Contains the action reducer coupled to one or more action types.\n */\nexport interface ReducerTypes<\n  State,\n  Creators extends readonly ActionCreator[]\n> {\n  reducer: OnReducer<State, Creators>;\n  types: ExtractActionTypes<Creators>;\n}\n\n/**\n *  Specialized Reducer that is aware of the Action type it needs to handle\n */\nexport interface OnReducer<\n  // State type that is being passed from consumer of `on` fn, e.g. from `createReducer` factory\n  State,\n  Creators extends readonly ActionCreator[],\n  // Inferred type from within OnReducer function if `State` is unknown\n  InferredState = State,\n  // Resulting state would be either a State or if State is unknown then the inferred state from the function itself\n  ResultState = unknown extends State ? InferredState : State\n> {\n  (\n    // if State is unknown then set the InferredState type\n    state: unknown extends State ? InferredState : State,\n    action: ActionType<Creators[number]>\n  ): ResultState;\n}\n\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * @returns an association of action types with a state change function.\n *\n * @usageNotes\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n */\nexport function on<\n  // State type that is being passed from `createReducer` when created within that factory function\n  State,\n  // Action creators\n  Creators extends readonly ActionCreator[],\n  // Inferred type from within OnReducer function if `State` is unknown. This is typically the case when `on` function\n  // is created outside of `createReducer` and state type is either explicitly set OR inferred by return type.\n  // For example: `const onFn = on(action, (state: State, {prop}) => ({ ...state, name: prop }));`\n  InferredState = State\n>(\n  ...args: [\n    ...creators: Creators,\n    reducer: OnReducer<\n      State extends infer S ? S : never,\n      Creators,\n      InferredState\n    >\n  ]\n): ReducerTypes<unknown extends State ? InferredState : State, Creators> {\n  const reducer = args.pop() as unknown as OnReducer<\n    unknown extends State ? InferredState : State,\n    Creators\n  >;\n  const types = (args as unknown as Creators).map(\n    (creator) => creator.type\n  ) as unknown as ExtractActionTypes<Creators>;\n  return { reducer, types };\n}\n\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.\n * - The returned `ActionReducer` does not require being wrapped with another function.\n *\n * **Declaring a reducer creator**\n *\n * ```ts\n * export const reducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n * ```\n */\nexport function createReducer<\n  S,\n  A extends Action = Action,\n  // Additional generic for the return type is introduced to enable correct\n  // type inference when `createReducer` is used within `createFeature`.\n  // For more info see: https://github.com/microsoft/TypeScript/issues/52114\n  R extends ActionReducer<S, A> = ActionReducer<S, A>\n>(initialState: S, ...ons: ReducerTypes<S, readonly ActionCreator[]>[]): R {\n  const map = new Map<string, OnReducer<S, ActionCreator[]>>();\n  for (const on of ons) {\n    for (const type of on.types) {\n      const existingReducer = map.get(type);\n      if (existingReducer) {\n        const newReducer: typeof existingReducer = (state, action) =>\n          on.reducer(existingReducer(state, action), action);\n        map.set(type, newReducer);\n      } else {\n        map.set(type, on.reducer);\n      }\n    }\n  }\n\n  return function (state: S = initialState, action: A): S {\n    const reducer = map.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  } as R;\n}\n"],
  "mappings": ";AAAO,IAAM,0BAA4D,CAAA;AAEnE,SAAU,6BAA0B;AACxC,aAAW,OAAO,OAAO,KAAK,uBAAuB,GAAG;AACtD,WAAO,wBAAwB,GAAG;EACpC;AACF;;;AC+FM,SAAU,aACd,MACA,QAA6B;AAE7B,0BAAwB,IAAI,KAAK,wBAAwB,IAAI,KAAK,KAAK;AAEvE,MAAI,OAAO,WAAW,YAAY;AAChC,WAAO,WAAW,MAAM,IAAI,UAAiB;MAC3C,GAAG,OAAO,GAAG,IAAI;MACjB;MACA;EACJ;AACA,QAAM,KAAK,SAAS,OAAO,MAAM;AACjC,UAAQ,IAAI;IACV,KAAK;AACH,aAAO,WAAW,MAAM,OAAO,EAAE,KAAI,EAAG;IAC1C,KAAK;AACH,aAAO,WAAW,MAAM,CAACA,YAAmB;QAC1C,GAAGA;QACH;QACA;IACJ;AACE,YAAM,IAAI,MAAM,oBAAoB;EACxC;AACF;AAEM,SAAU,QAAK;AAKnB,SAAO,EAAE,KAAK,SAAS,IAAI,OAAU;AACvC;AAEM,SAAU,MAEd,UAAW;AAEX,SAAO;AACT;AAEA,SAAS,WACP,MACA,SAAgB;AAEhB,SAAO,OAAO,eAAe,SAAS,QAAQ;IAC5C,OAAO;IACP,UAAU;GACX;AACH;;;ACtJM,SAAU,WAA6B,MAAO;AAClD,SAAQ,KAAK,OAAO,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC;AACzD;AAEM,SAAU,aAA+B,MAAO;AACpD,SAAQ,KAAK,OAAO,CAAC,EAAE,YAAW,IAAK,KAAK,UAAU,CAAC;AACzD;;;AC+HM,SAAU,kBAGd,QAAyC;AACzC,QAAM,EAAE,QAAQ,OAAM,IAAK;AAE3B,SAAO,OAAO,KAAK,MAAM,EAAE,OACzB,CAAC,aAAa,eAAe;IAC3B,GAAG;IACH,CAAC,aAAa,SAAS,CAAC,GAAG,aACzB,aAAa,QAAQ,SAAS,GAC7B,OAAe,SAAS,CAAC;MAG9B,CAAA,CAAiC;AAErC;AAEM,SAAU,aAAU;AACxB,SAAO,MAAK;AACd;AAEA,SAAS,aACP,WAAoB;AAEpB,SAAO,UACJ,KAAI,EACJ,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,MAAO,MAAM,IAAI,aAAa,IAAI,IAAI,WAAW,IAAI,CAAE,EAClE,KAAK,EAAE;AACZ;AAEA,SAAS,aACP,QACA,WAAoB;AAEpB,SAAO,IAAI,MAAM,KAAK,SAAS;AACjC;;;AC1KA,SAAS,kBAAuC;AAChD,SAAS,uBAAuB;;AAIzB,IAAM,OAAO;AAGd,IAAO,iBAAP,MAAO,wBACH,gBAAuB;EAG/B,cAAA;AACE,UAAM,EAAE,MAAM,KAAI,CAAE;EACtB;EAES,KAAK,QAAc;AAC1B,QAAI,OAAO,WAAW,YAAY;AAChC,YAAM,IAAI,UAAU;;;uFAG6D;IACnF,WAAW,OAAO,WAAW,aAAa;AACxC,YAAM,IAAI,UAAU,yBAAyB;IAC/C,WAAW,OAAO,OAAO,SAAS,aAAa;AAC7C,YAAM,IAAI,UAAU,mCAAmC;IACzD;AACA,UAAM,KAAK,MAAM;EACnB;EAES,WAAQ;EAEjB;EAEA,cAAW;AACT,UAAM,SAAQ;EAChB;;4GA5BW,iBAAc,MAAA,CAAA,GAAA,QAAA,mBAAA,WAAA,CAAA;EAAA;;gHAAd,gBAAc,CAAA;EAAA;;kGAAd,gBAAc,YAAA,CAAA;QAD1B;;AAgCM,IAAM,4BAAwC,CAAC,cAAc;;;ACvCpE,SAAS,sBAAsB;AAGxB,IAAM,oBAAoB,IAAI,eACnC,iCAAiC;AAE5B,IAAM,iBAAiB,IAAI,eAChC,oCAAoC;AAE/B,IAAM,gBAAgB,IAAI,eAAe,2BAA2B;AACpE,IAAM,kBAAkB,IAAI,eACjC,6BAA6B;AAExB,IAAM,mBAAmB,IAAI,eAClC,+CAA+C;AAE1C,IAAM,mBAAmB,IAAI,eAClC,8BAA8B;AAEzB,IAAM,oBAAoB,IAAI,eACnC,uCAAuC;AAElC,IAAM,iBAAiB,IAAI,eAAe,4BAA4B;AACtE,IAAM,kBAAkB,IAAI,eACjC,qCAAqC;AAEhC,IAAM,oBAAoB,IAAI,eACnC,uCAAuC;AAGlC,IAAM,mBAAmB,IAAI,eAClC,sCAAsC;AAGjC,IAAM,kBAAkB,IAAI,eACjC,qCAAqC;AAGhC,IAAM,0BAA0B,IAAI,eACzC,6CAA6C;AAExC,IAAM,mBAAmB,IAAI,eAClC,8BAA8B;AAMzB,IAAM,8BAA8B,IAAI,eAC7C,yCAAyC;AAMpC,IAAM,gBAAgB,IAAI,eAC/B,2BAA2B;AAOtB,IAAM,0BAA0B,IAAI,eACzC,6CAA6C;AAOxC,IAAM,sBAAsB,IAAI,eACrC,wCAAwC;AAMnC,IAAM,uBAAuB,IAAI,eACtC,iDAAiD;AAM5C,IAAM,wBAAwB,IAAI,eACvC,qCAAqC;AAGhC,IAAM,gCAAgC,IAAI,eAC/C,8CAA8C;AASzC,IAAM,sBAAsB,IAAI,eACrC,iCAAiC;AAS5B,IAAM,yBAAyB,IAAI,eACxC,oCAAoC;;;AChEhC,SAAU,gBACd,UACA,eAAoB,CAAA,GAAE;AAEtB,QAAM,cAAc,OAAO,KAAK,QAAQ;AACxC,QAAM,gBAAqB,CAAA;AAE3B,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,UAAM,MAAM,YAAY,CAAC;AACzB,QAAI,OAAO,SAAS,GAAG,MAAM,YAAY;AACvC,oBAAc,GAAG,IAAI,SAAS,GAAG;IACnC;EACF;AAEA,QAAM,mBAAmB,OAAO,KAAK,aAAa;AAElD,SAAO,SAAS,YAAY,OAAO,QAAM;AACvC,YAAQ,UAAU,SAAY,eAAe;AAC7C,QAAI,aAAa;AACjB,UAAM,YAAiB,CAAA;AACvB,aAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,YAAM,MAAM,iBAAiB,CAAC;AAC9B,YAAM,UAAe,cAAc,GAAG;AACtC,YAAM,sBAAsB,MAAM,GAAG;AACrC,YAAM,kBAAkB,QAAQ,qBAAqB,MAAM;AAE3D,gBAAU,GAAG,IAAI;AACjB,mBAAa,cAAc,oBAAoB;IACjD;AACA,WAAO,aAAa,YAAY;EAClC;AACF;AAEM,SAAU,KACd,QACA,aAAoB;AAEpB,SAAO,OAAO,KAAK,MAAM,EACtB,OAAO,CAAC,QAAQ,QAAQ,WAAW,EACnC,OAAO,CAAC,QAAQ,QAAQ,OAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,OAAO,GAAG,EAAC,CAAE,GAAG,CAAA,CAAE;AAC9E;AAwBM,SAAU,WAAW,WAAgB;AACzC,SAAO,SAAU,KAAQ;AACvB,QAAI,UAAU,WAAW,GAAG;AAC1B,aAAO;IACT;AAEA,UAAM,OAAO,UAAU,UAAU,SAAS,CAAC;AAC3C,UAAM,OAAO,UAAU,MAAM,GAAG,EAAE;AAElC,WAAO,KAAK,YAAY,CAAC,UAAU,OAAO,GAAG,QAAQ,GAAG,KAAK,GAAG,CAAC;EACnE;AACF;AAEM,SAAU,qBACd,gBACA,cAAkC;AAElC,MAAI,MAAM,QAAQ,YAAY,KAAK,aAAa,SAAS,GAAG;AACzD,qBAAyB,QAAQ,MAAM,MAAM;MAC5C,GAAG;MACH;KACD;EACH;AAEA,SAAO,CAAC,UAAkC,iBAAkC;AAC1E,UAAM,UAAU,eAAe,QAAQ;AACvC,WAAO,CAAC,OAAsB,WAAa;AACzC,cAAQ,UAAU,SAAa,eAAqB;AACpD,aAAO,QAAQ,OAAO,MAAM;IAC9B;EACF;AACF;AAEM,SAAU,4BACd,cAAkC;AAElC,QAAM,iBACJ,MAAM,QAAQ,YAAY,KAAK,aAAa,SAAS,IACjD,QAA6B,GAAG,YAAY,IAC5C,CAAC,MAA2B;AAElC,SAAO,CAAC,SAA8B,iBAAoB;AACxD,cAAU,eAAe,OAAO;AAEhC,WAAO,CAAC,OAAsB,WAAa;AACzC,cAAQ,UAAU,SAAY,eAAe;AAC7C,aAAO,QAAQ,OAAO,MAAM;IAC9B;EACF;AACF;;;AC/JA,SAAS,QAAQ,cAAAC,mBAAuC;AACxD,SAAS,mBAAAC,kBAAiB,kBAAkB;;AAgBtC,IAAgB,oBAAhB,cAA0C,WAE/C;;AACK,IAAgB,2BAAhB,cAAiD,eAAc;;AAC9D,IAAM,SAAS;AAGhB,IAAO,iBAAP,MAAO,wBACHA,iBAAwC;EAGhD,IAAI,kBAAe;AACjB,WAAO,KAAK;EACd;EAEA,YACU,YACuB,cACG,UAE1B,gBAA8C;AAEtD,UAAM,eAAe,UAAU,YAAY,CAAC;AANpC,SAAA,aAAA;AACuB,SAAA,eAAA;AACG,SAAA,WAAA;AAE1B,SAAA,iBAAA;EAGV;EAEA,WAAW,SAA+B;AACxC,SAAK,YAAY,CAAC,OAAO,CAAC;EAC5B;EAEA,YAAY,UAAkC;AAC5C,UAAM,WAAW,SAAS,OACxB,CACE,aACA,EAAE,UAAAC,WAAU,gBAAgB,cAAc,cAAc,IAAG,MACzD;AACF,YAAM,UACJ,OAAOA,cAAa,aAChB,4BAA4B,YAAY,EAAEA,WAAU,YAAY,IAChE,qBAAqB,gBAAgB,YAAY,EAC/CA,WACA,YAAY;AAGpB,kBAAY,GAAG,IAAI;AACnB,aAAO;IACT,GACA,CAAA,CAAgD;AAGlD,SAAK,YAAY,QAAQ;EAC3B;EAEA,cAAc,SAA+B;AAC3C,SAAK,eAAe,CAAC,OAAO,CAAC;EAC/B;EAEA,eAAe,UAAkC;AAC/C,SAAK,eAAe,SAAS,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC;EAChD;EAEA,WAAW,KAAa,SAAgC;AACtD,SAAK,YAAY,EAAE,CAAC,GAAG,GAAG,QAAO,CAAE;EACrC;EAEA,YAAY,UAAoD;AAC9D,SAAK,WAAW,EAAE,GAAG,KAAK,UAAU,GAAG,SAAQ;AAC/C,SAAK,eAAe,OAAO,KAAK,QAAQ,CAAC;EAC3C;EAEA,cAAc,YAAkB;AAC9B,SAAK,eAAe,CAAC,UAAU,CAAC;EAClC;EAEA,eAAe,aAAqB;AAClC,gBAAY,QAAQ,CAAC,QAAO;AAC1B,WAAK,WAAW,KAAK,KAAK,UAAU,GAAG;IACzC,CAAC;AACD,SAAK,eAAe,WAAW;EACjC;EAEQ,eAAe,aAAqB;AAC1C,SAAK,KAAK,KAAK,eAAe,KAAK,UAAU,KAAK,YAAY,CAAC;AAC/D,SAAK,WAAW,KAAa;MAC3B,MAAM;MACN,UAAU;KACX;EACH;EAEA,cAAW;AACT,SAAK,SAAQ;EACf;;8GAnFW,iBAAc,MAAA,CAAA,EAAA,OAAA,yBAAA,GAAA,EAAA,OAUf,cAAa,GAAA,EAAA,OACb,iBAAgB,GAAA,EAAA,OAChB,gBAAe,CAAA,GAAA,QAAA,oBAAA,WAAA,CAAA;EAAA;;kHAZd,gBAAc,CAAA;EAAA;;oGAAd,gBAAc,YAAA,CAAA;QAD1BF;;QAWI;SAAO,aAAa;;QACpB;SAAO,gBAAgB;;QACvB;SAAO,eAAe;;AA0EpB,IAAM,4BAAwC;EACnD;EACA,EAAE,SAAS,mBAAmB,aAAa,eAAc;EACzD,EAAE,SAAS,0BAA0B,aAAa,eAAc;;;;ACjHlE,SAAS,cAAAG,mBAAuC;AAChD,SAAS,eAAe;;AAKlB,IAAO,wBAAP,MAAO,+BACH,QAAe;EAGvB,cAAW;AACT,SAAK,SAAQ;EACf;;8GANW,wBAAqB,MAAA,MAAA,QAAA,oBAAA,WAAA,CAAA;EAAA;;kHAArB,uBAAqB,CAAA;EAAA;;oGAArB,uBAAqB,YAAA,CAAA;QADjCA;;AAUM,IAAM,oCAAgD;EAC3D;;;;AChBF,SAAS,UAAAC,SAAQ,cAAAC,mBAA+C;AAChE,SAAS,gBAAgB;AACzB,SACE,mBAAAC,kBACA,cAAAC,aACA,sBAEK;AACP,SAAS,WAAW,MAAM,sBAAsB;;AAQ1C,IAAgB,kBAAhB,cAAwCA,YAAe;;AAQvD,IAAO,QAAP,MAAO,eAAiBD,iBAAoB;;AAChC,SAAA,OAAO;EAAK;EAS5B,YACE,UACA,UACA,gBACuB,cAAiB;AAExC,UAAM,YAAY;AAElB,UAAM,kBAAsC,SAAS,KACnD,UAAU,cAAc,CAAC;AAE3B,UAAM,qBACJ,gBAAgB,KAAK,eAAe,QAAQ,CAAC;AAE/C,UAAM,OAA2B,EAAE,OAAO,aAAY;AACtD,UAAM,kBAGD,mBAAmB,KACtB,KACE,aACA,IAAI,CACL;AAGH,SAAK,oBAAoB,gBAAgB,UAAU,CAAC,EAAE,OAAO,OAAM,MAAM;AACvE,WAAK,KAAK,KAAK;AACf,qBAAe,KAAK,MAAgB;IACtC,CAAC;AAED,SAAK,QAAQ,SAAS,MAAM,EAAE,eAAe,MAAM,aAAa,KAAI,CAAE;EACxE;EAEA,cAAW;AACT,SAAK,kBAAkB,YAAW;AAClC,SAAK,SAAQ;EACf;;8GA9CW,QAAK,MAAA,CAAA,EAAA,OAAA,eAAA,GAAA,EAAA,OAAA,kBAAA,GAAA,EAAA,OAAA,sBAAA,GAAA,EAAA,OAcN,cAAa,CAAA,GAAA,QAAA,oBAAA,WAAA,CAAA;EAAA;;kHAdZ,OAAK,CAAA;EAAA;;oGAAL,OAAK,YAAA,CAAA;QADjBD;;QAeID;SAAO,aAAa;;AAuCnB,SAAU,YACd,kBAAyC,EAAE,OAAO,OAAS,GAC3D,CAAC,QAAQ,OAAO,GAA2B;AAE3C,QAAM,EAAE,MAAK,IAAK;AAClB,SAAO,EAAE,OAAO,QAAQ,OAAO,MAAM,GAAG,OAAM;AAChD;AAEO,IAAM,kBAA8B;EACzC;EACA,EAAE,SAAS,iBAAiB,aAAa,MAAK;;;;ACtFhD,SAAS,UAAU,cAAAI,mBAAoC;AACvD,SAAS,cAAAC,mBAAsC;AAC/C,SAAS,sBAAsB,KAAK,aAAa;;AAa3C,IAAO,QAAP,MAAO,eACHA,YAAa;EAQrB,YACE,QACQ,iBACA,gBAA8B;AAEtC,UAAK;AAHG,SAAA,kBAAA;AACA,SAAA,iBAAA;AAIR,SAAK,SAAS;AACd,SAAK,QAAQ,OAAO;EACtB;EAiEA,OACE,gBACG,OAAe;AAElB,WAAQ,OAAe,KAAK,MAAM,aAAa,GAAG,KAAK,EAAE,IAAI;EAC/D;;;;;;;EAQA,aACE,UACA,SAAgC;AAEhC,WAAO,SAAS,MAAM,SAAS,KAAK,MAAK,CAAE,GAAG,OAAO;EACvD;EAES,KAAQ,UAAwB;AACvC,UAAM,QAAQ,IAAI,OAAS,MAAM,KAAK,iBAAiB,KAAK,cAAc;AAC1E,UAAM,WAAW;AAEjB,WAAO;EACT;EAEA,SACE,QAIG;AAEH,SAAK,gBAAgB,KAAK,MAAM;EAClC;EAEA,KAAK,QAAc;AACjB,SAAK,gBAAgB,KAAK,MAAM;EAClC;EAEA,MAAM,KAAQ;AACZ,SAAK,gBAAgB,MAAM,GAAG;EAChC;EAEA,WAAQ;AACN,SAAK,gBAAgB,SAAQ;EAC/B;EAEA,WACE,KACA,SAAsC;AAEtC,SAAK,eAAe,WAAW,KAAK,OAAO;EAC7C;EAEA,cAAoD,KAAQ;AAC1D,SAAK,eAAe,cAAc,GAAG;EACvC;;8GA7IW,QAAK,MAAA,CAAA,EAAA,OAAA,gBAAA,GAAA,EAAA,OAAA,eAAA,GAAA,EAAA,OAAA,eAAA,CAAA,GAAA,QAAA,oBAAA,WAAA,CAAA;EAAA;;kHAAL,OAAK,CAAA;EAAA;;oGAAL,OAAK,YAAA,CAAA;QADjBD;;AAiJM,IAAM,kBAA8B,CAAC,KAAK;AAyF3C,SAAU,OACd,aACA,gBACG,OAAe;AAElB,SAAO,SAAS,eAAe,SAAsB;AACnD,QAAI;AAEJ,QAAI,OAAO,gBAAgB,UAAU;AACnC,YAAM,aAAa,CAAS,aAAa,GAAG,KAAK,EAAE,OAAO,OAAO;AACjE,gBAAU,QAAQ,KAAK,MAAM,aAAa,GAAG,UAAU,CAAC;IAC1D,WAAW,OAAO,gBAAgB,YAAY;AAC5C,gBAAU,QAAQ,KAChB,IAAI,CAAC,WAAW,YAAY,QAAe,WAAW,CAAC,CAAC;IAE5D,OAAO;AACL,YAAM,IAAI,UACR,oBAAoB,OAAO,WAAW,uDACF;IAExC;AAEA,WAAO,QAAQ,KAAK,qBAAoB,CAAE;EAC5C;AACF;;;ACjRO,IAAM,oBACX;AAEI,SAAU,YAAY,QAAW;AACrC,SAAO,WAAW;AACpB;AAEM,SAAU,OAAO,QAAW;AAChC,SAAO,WAAW;AACpB;AAEM,SAAU,QAAQ,QAAW;AACjC,SAAO,MAAM,QAAQ,MAAM;AAC7B;AAEM,SAAU,SAAS,QAAW;AAClC,SAAO,OAAO,WAAW;AAC3B;AAEM,SAAU,UAAU,QAAW;AACnC,SAAO,OAAO,WAAW;AAC3B;AAEM,SAAU,SAAS,QAAW;AAClC,SAAO,OAAO,WAAW;AAC3B;AAEM,SAAU,aAAa,QAAW;AACtC,SAAO,OAAO,WAAW,YAAY,WAAW;AAClD;AAEM,SAAU,SAAS,QAAW;AAClC,SAAO,aAAa,MAAM,KAAK,CAAC,QAAQ,MAAM;AAChD;AAEM,SAAU,cAAc,QAAW;AACvC,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO;EACT;AAEA,QAAM,kBAAkB,OAAO,eAAe,MAAM;AACpD,SAAO,oBAAoB,OAAO,aAAa,oBAAoB;AACrE;AAEM,SAAU,WAAW,QAAW;AACpC,SAAO,OAAO,WAAW;AAC3B;AAEM,SAAU,YAAY,QAAW;AACrC,SAAO,WAAW,MAAM,KAAK,OAAO,eAAe,MAAM;AAC3D;AAEM,SAAU,eAAe,QAAgB,cAAoB;AACjE,SAAO,OAAO,UAAU,eAAe,KAAK,QAAQ,YAAY;AAClE;;;ACtDA,IAAI,uBAAuB;AACrB,SAAU,uBAAuB,OAAc;AACnD,yBAAuB;AACzB;AACM,SAAU,wBAAqB;AACnC,SAAO;AACT;;;ACLA,SAAS,iBAAiB;AA4CpB,SAAU,aAAa,GAAQ,GAAM;AACzC,SAAO,MAAM;AACf;AAEA,SAAS,mBACP,MACA,eACA,YAAwB;AAExB,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,QAAI,CAAC,WAAW,KAAK,CAAC,GAAG,cAAc,CAAC,CAAC,GAAG;AAC1C,aAAO;IACT;EACF;AACA,SAAO;AACT;AAEM,SAAU,cACd,cACA,eAA2B;AAE3B,SAAO,eAAe,cAAc,cAAc,aAAa;AACjE;AAEM,SAAU,eACd,cACA,mBAAmB,cACnB,gBAAgB,cAAY;AAE5B,MAAI,gBAAmC;AAEvC,MAAI,aAAkB;AACtB,MAAI;AAEJ,WAAS,QAAK;AACZ,oBAAgB;AAChB,iBAAa;EACf;AAEA,WAAS,UAAU,SAAc,QAAS;AACxC,qBAAiB,EAAE,OAAM;EAC3B;AAEA,WAAS,cAAW;AAClB,qBAAiB;EACnB;AAKA,WAAS,WAAQ;AACf,QAAI,mBAAmB,QAAW;AAChC,aAAO,eAAe;IACxB;AAEA,QAAI,CAAC,eAAe;AAClB,mBAAa,aAAa,MAAM,MAAM,SAAgB;AACtD,sBAAgB;AAChB,aAAO;IACT;AAEA,QAAI,CAAC,mBAAmB,WAAW,eAAe,gBAAgB,GAAG;AACnE,aAAO;IACT;AAEA,UAAM,YAAY,aAAa,MAAM,MAAM,SAAgB;AAC3D,oBAAgB;AAEhB,QAAI,cAAc,YAAY,SAAS,GAAG;AACxC,aAAO;IACT;AAEA,iBAAa;AAEb,WAAO;EACT;AAEA,SAAO,EAAE,UAAU,OAAO,WAAW,YAAW;AAClD;AA4YM,SAAU,kBACX,OAAY;AAEf,SAAO,sBAAsB,cAAc,EAAE,GAAG,KAAK;AACvD;AAEM,SAAU,eACd,OACA,WACAE,QACA,mBAAqC;AAErC,MAAIA,WAAU,QAAW;AACvB,UAAMC,QAA8B,UAAW,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;AACpE,WAAO,kBAAkB,SAAS,MAAM,MAAMA,KAAI;EACpD;AAEA,QAAM,OAA4C,UAAW,IAAI,CAAC,OAChE,GAAG,OAAOD,MAAK,CAAC;AAElB,SAAO,kBAAkB,SAAS,MAAM,MAAM,CAAC,GAAG,MAAMA,MAAK,CAAC;AAChE;AA2GM,SAAU,sBACd,SACA,UAA2C;EACzC,SAAS;GACV;AAED,SAAO,YACF,OAAY;AAEf,QAAI,OAAO;AACX,QAAI,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AAC1B,YAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,aAAO,CAAC,GAAG,MAAM,GAAG,IAAI;IAC1B,WAAW,KAAK,WAAW,KAAK,sBAAsB,KAAK,CAAC,CAAC,GAAG;AAC9D,aAAO,mCAAmC,KAAK,CAAC,CAAC;IACnD;AAEA,UAAM,YAAY,KAAK,MAAM,GAAG,KAAK,SAAS,CAAC;AAC/C,UAAM,YAAY,KAAK,KAAK,SAAS,CAAC;AACtC,UAAM,oBAAoB,UAAU,OAClC,CAAC,aACC,SAAS,WAAW,OAAO,SAAS,YAAY,UAAU;AAG9D,UAAM,oBAAoB,QAAQ,YAAaE,YAAgB;AAC7D,aAAO,UAAU,MAAM,MAAMA,UAAS;IACxC,CAAC;AAED,UAAM,gBAAgB,eAAe,SAAU,OAAYF,QAAU;AACnE,aAAO,QAAQ,QAAQ,MAAM,MAAM;QACjC;QACA;QACAA;QACA;OACD;IACH,CAAC;AAED,aAAS,UAAO;AACd,oBAAc,MAAK;AACnB,wBAAkB,MAAK;AAEvB,wBAAkB,QAAQ,CAAC,aAAa,SAAS,QAAO,CAAE;IAC5D;AAEA,WAAO,OAAO,OAAO,cAAc,UAAU;MAC3C;MACA,WAAW,kBAAkB;MAC7B,WAAW,cAAc;MACzB,aAAa,cAAc;KAC5B;EACH;AACF;AAWM,SAAU,sBACd,aAAgB;AAEhB,SAAO,eACL,CAAC,UAAc;AACb,UAAM,eAAe,MAAM,WAAW;AACtC,QAAI,CAAC,sBAAqB,KAAM,UAAS,KAAM,EAAE,eAAe,QAAQ;AACtE,cAAQ,KACN,kCAAkC,WAAW,0JAGb,WAAW,sCACd,WAAW,qJAEwB;IAEpE;AACA,WAAO;EACT,GACA,CAAC,iBAAsB,YAAY;AAEvC;AAEA,SAAS,sBACP,WAAkB;AAElB,SACE,CAAC,CAAC,aACF,OAAO,cAAc,YACrB,OAAO,OAAO,SAAS,EAAE,MAAM,CAAC,aAAa,OAAO,aAAa,UAAU;AAE/E;AAEA,SAAS,mCACP,qBAA+D;AAK/D,QAAM,YAAY,OAAO,OAAO,mBAAmB;AACnD,QAAM,aAAa,OAAO,KAAK,mBAAmB;AAClD,QAAM,YAAY,IAAI,oBACpB,WAAW,OACT,CAAC,QAAQ,KAAK,WAAW;IACvB,GAAG;IACH,CAAC,GAAG,GAAG,gBAAgB,KAAK;MAE9B,CAAA,CAAE;AAGN,SAAO,CAAC,GAAG,WAAW,SAAS;AACjC;;;AChjBM,SAAU,cAKd,eAMC;AAED,QAAM,EACJ,MACA,SACA,gBAAgB,sBAAqB,IACnC;AAEJ,QAAM,kBAAkB,sBAAoC,IAAI;AAChE,QAAM,kBAAkB,sBAAsB,iBAAiB,OAAO;AACtE,QAAM,gBAAgB;IACpB,CAAC,SAAS,WAAW,IAAI,CAAC,OAAO,GAAG;IACpC,GAAG;;AAEL,QAAM,iBAAiB,wBACnB,sBAAsB,aAAa,IACnC,CAAA;AAEJ,SAAO;IACL;IACA;IACA,GAAG;IACH,GAAG;;AAEP;AAEA,SAAS,sBACP,iBACA,SAAoC;AAEpC,QAAM,eAAe,gBAAgB,OAAO;AAC5C,QAAM,aACJ,cAAc,YAAY,IAAI,OAAO,KAAK,YAAY,IAAI,CAAA;AAG5D,SAAO,WAAW,OAChB,CAAC,iBAAiB,eAAe;IAC/B,GAAG;IACH,CAAC,SAAS,WAAW,SAAS,CAAC,EAAE,GAAG,eAClC,iBACA,CAAC,gBAAgB,cAAc,SAAS,CAAC;MAG7C,CAAA,CAAmC;AAEvC;AAEA,SAAS,gBACP,SAAoC;AAEpC,SAAO,QAAQ,QAAW,EAAE,MAAM,qBAAoB,CAAE;AAC1D;;;ACtQA,SAAS,QAAQ,kBAAAG,uBAAsB;AAiCjC,SAAU,qBACd,UAAyE;AAEzE,SAAO,oBAAoBA,kBAAiB,OAAO,QAAQ,IAAI;AACjE;AAEM,SAAU,oBACd,SACA,eAAmC;AAEnC,SAAO,cAAc,IAAI,CAAC,MAAM,UAAS;AACvC,QAAI,QAAQ,KAAK,aAAaA,iBAAgB;AAC5C,YAAM,OAAO,OAAO,QAAQ,KAAK,CAAsC;AACvE,aAAO;QACL,KAAK,KAAK;QACV,gBAAgB,KAAK,iBACjB,KAAK,iBACL;QACJ,cAAc,KAAK,eAAe,KAAK,eAAe,CAAA;QACtD,cAAc,KAAK;;IAEvB;AACA,WAAO;EACT,CAAC;AACH;AAEM,SAAU,uBACd,mBAEC;AAED,SAAO,kBAAkB,IAAI,CAAC,YAAW;AACvC,WAAO,mBAAmBA,kBAAiB,OAAO,OAAO,IAAI;EAC/D,CAAC;AACH;AAEM,SAAU,qBAAqB,cAAiB;AACpD,MAAI,OAAO,iBAAiB,YAAY;AACtC,WAAO,aAAY;EACrB;AAEA,SAAO;AACT;AAEM,SAAU,oBACd,cACA,0BAAuC;AAEvC,SAAO,aAAa,OAAO,wBAAwB;AACrD;AAEM,SAAU,uBAAoB;AAClC,QAAM,QAAQ,OAAO,OAAO,EAAE,UAAU,MAAM,UAAU,KAAI,CAAE;AAC9D,MAAI,OAAO;AACT,UAAM,IAAI,UACR,yGAAyG;EAE7G;AACA,SAAO;AACT;;;ACzFM,SAAU,6BACd,SACA,QAAqE;AAErE,SAAO,SAAU,OAAO,QAAM;AAC5B,UAAM,MAAM,OAAO,OAAO,MAAM,IAAI,OAAO,MAAM,IAAI;AAErD,UAAM,YAAY,QAAQ,OAAO,GAAG;AAEpC,WAAO,OAAO,MAAK,IAAK,OAAO,SAAS,IAAI;EAC9C;AACF;AAEA,SAAS,OAAO,QAAW;AACzB,SAAO,OAAO,MAAM;AAEpB,QAAM,mBAAmB,WAAW,MAAM;AAE1C,SAAO,oBAAoB,MAAM,EAAE,QAAQ,CAAC,SAAQ;AAElD,QAAI,KAAK,WAAW,GAAG,GAAG;AACxB;IACF;AAEA,QACE,eAAe,QAAQ,IAAI,MAC1B,mBACG,SAAS,YAAY,SAAS,YAAY,SAAS,cACnD,OACJ;AACA,YAAM,YAAY,OAAO,IAAI;AAE7B,WACG,aAAa,SAAS,KAAK,WAAW,SAAS,MAChD,CAAC,OAAO,SAAS,SAAS,GAC1B;AACA,eAAO,SAAS;MAClB;IACF;EACF,CAAC;AAED,SAAO;AACT;;;AChCM,SAAU,8BACd,SACA,QAAqE;AAErE,SAAO,SAAU,OAAO,QAAM;AAC5B,QAAI,OAAO,OAAO,MAAM,GAAG;AACzB,YAAM,uBAAuB,kBAAkB,MAAM;AACrD,4BAAsB,sBAAsB,QAAQ;IACtD;AAEA,UAAM,YAAY,QAAQ,OAAO,MAAM;AAEvC,QAAI,OAAO,MAAK,GAAI;AAClB,YAAM,sBAAsB,kBAAkB,SAAS;AACvD,4BAAsB,qBAAqB,OAAO;IACpD;AAEA,WAAO;EACT;AACF;AAEA,SAAS,kBACP,QACA,OAAiB,CAAA,GAAE;AAGnB,OAAK,YAAY,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,WAAW,GAAG;AAChE,WAAO;MACL,MAAM,CAAC,MAAM;MACb,OAAO;;EAEX;AAEA,QAAM,OAAO,OAAO,KAAK,MAAM;AAC/B,SAAO,KAAK,OAA+C,CAAC,QAAQ,QAAO;AACzE,QAAI,QAAQ;AACV,aAAO;IACT;AAEA,UAAM,QAAS,OAAe,GAAG;AAGjC,QAAI,YAAY,KAAK,GAAG;AACtB,aAAO;IACT;AAEA,QACE,YAAY,KAAK,KACjB,OAAO,KAAK,KACZ,SAAS,KAAK,KACd,UAAU,KAAK,KACf,SAAS,KAAK,KACd,QAAQ,KAAK,GACb;AACA,aAAO;IACT;AAEA,QAAI,cAAc,KAAK,GAAG;AACxB,aAAO,kBAAkB,OAAO,CAAC,GAAG,MAAM,GAAG,CAAC;IAChD;AAEA,WAAO;MACL,MAAM,CAAC,GAAG,MAAM,GAAG;MACnB;;EAEJ,GAAG,KAAK;AACV;AAEA,SAAS,sBACP,gBACA,SAA2B;AAE3B,MAAI,mBAAmB,OAAO;AAC5B;EACF;AAEA,QAAM,qBAAqB,eAAe,KAAK,KAAK,GAAG;AACvD,QAAM,QAAa,IAAI,MACrB,2BAA2B,OAAO,QAAQ,kBAAkB,MAAM,iBAAiB,UAAU,OAAO,iBAAiB;AAEvH,QAAM,QAAQ,eAAe;AAC7B,QAAM,qBAAqB;AAC3B,QAAM;AACR;;;AChGA,YAAY,YAAY;AAIlB,SAAU,0BACd,SACA,QAA+C;AAE/C,SAAO,SAAU,OAAY,QAAc;AACzC,QAAI,OAAO,OAAO,MAAM,KAAK,CAAQ,cAAO,gBAAe,GAAI;AAC7D,YAAM,IAAI,MACR,WAAW,OAAO,IAAI,6BAA6B,iBAAiB,2BAA2B;IAEnG;AACA,WAAO,QAAQ,OAAO,MAAM;EAC9B;AACF;;;AChBA,SAAS,aAAAC,kBAA2B;AAiB9B,SAAU,0BACd,eAAsC;AAEtC,MAAIA,WAAS,GAAI;AACf,WAAO;MACL,4BAA4B;MAC5B,6BAA6B;MAC7B,yBAAyB;MACzB,0BAA0B;MAC1B,0BAA0B;MAC1B,4BAA4B;MAC5B,GAAG;;EAEP;AAEA,SAAO;IACL,4BAA4B;IAC5B,6BAA6B;IAC7B,yBAAyB;IACzB,0BAA0B;IAC1B,0BAA0B;IAC1B,4BAA4B;;AAEhC;AAEM,SAAU,oCAAoC,EAClD,6BACA,2BAA0B,GACZ;AACd,SAAO,CAAC,YACN,+BAA+B,6BAC3B,8BAA8B,SAAS;IACrC,QAAQ,CAAC,WACP,+BAA+B,CAAC,iBAAiB,MAAM;IACzD,OAAO,MAAM;GACd,IACD;AACR;AAEM,SAAU,mCAAmC,EACjD,0BACA,wBAAuB,GACT;AACd,SAAO,CAAC,YACN,4BAA4B,0BACxB,6BAA6B,SAAS;IACpC,QAAQ,CAAC,WACP,4BAA4B,CAAC,iBAAiB,MAAM;IACtD,OAAO,MAAM;GACd,IACD;AACR;AAEA,SAAS,iBAAiB,QAAc;AACtC,SAAO,OAAO,KAAK,WAAW,OAAO;AACvC;AAEM,SAAU,+BAA+B,EAC7C,yBAAwB,GACV;AACd,SAAO,CAAC,YACN,2BACI,0BAA0B,SAAS;IACjC,QAAQ,CAAC,WACP,4BAA4B,CAAC,iBAAiB,MAAM;GACvD,IACD;AACR;AAEM,SAAU,qBACd,eAAsC;AAEtC,SAAO;IACL;MACE,SAAS;MACT,UAAU;;IAEZ;MACE,SAAS;MACT,YAAY;MACZ,MAAM,CAAC,oBAAoB;;IAE7B;MACE,SAAS;MACT,MAAM,CAAC,mBAAmB;MAC1B,YAAY;;IAEd;MACE,SAAS;MACT,OAAO;MACP,MAAM,CAAC,qBAAqB;MAC5B,YAAY;;IAEd;MACE,SAAS;MACT,OAAO;MACP,MAAM,CAAC,qBAAqB;MAC5B,YAAY;;IAEd;MACE,SAAS;MACT,OAAO;MACP,MAAM,CAAC,qBAAqB;MAC5B,YAAY;;;AAGlB;AAEM,SAAU,+BAA4B;AAC1C,SAAO;IACL;MACE,SAAS;MACT,OAAO;MACP,MAAM,CAAC,qBAAqB;MAC5B,YAAY;;;AAGlB;AAEM,SAAU,sBACd,eAA4B;AAE5B,SAAO;AACT;AAEM,SAAU,2BAA2B,QAAqB;AAC9D,MAAI,CAAC,OAAO,4BAA4B;AACtC;EACF;AAEA,QAAM,aAAa,OAAO,QAAQ,uBAAuB,EACtD,OAAO,CAAC,CAAC,EAAE,aAAa,MAAM,gBAAgB,CAAC,EAC/C,IAAI,CAAC,CAAC,IAAI,MAAM,IAAI;AAEvB,MAAI,WAAW,QAAQ;AACrB,UAAM,IAAI,MACR,+CAA+C,WAC5C,IAAI,CAAC,SAAS,IAAI,IAAI,GAAG,EACzB,KAAK,IAAI,CAAC,KAAK,iBAAiB,6BAA6B;EAEpE;AACF;;;AC9JA,SACE,yBAEA,UAAAC,SACA,UAAAC,SACA,kBAAAC,iBACA,gCAEK;AA4FD,SAAU,aACd,oBACA,UAKA,SAAgE,CAAA,GAAE;AAElE,SAAO,yBAAyB;IAC9B,GAAG,cAAc,oBAAoB,UAAU,MAAM;IACrD;GACD;AACH;AAEM,SAAU,cACd,WAG4B,CAAA,GAC5B,SAAgC,CAAA,GAAE;AAElC,SAAO;IACL;MACE,SAAS;MACT,YAAY;;IAEd,EAAE,SAAS,gBAAgB,UAAU,OAAO,aAAY;IACxD;MACE,SAAS;MACT,YAAY;MACZ,MAAM,CAAC,cAAc;;IAEvB,EAAE,SAAS,mBAAmB,UAAU,SAAQ;IAChD;MACE,SAAS;MACT,aACE,oBAAoBA,kBAAiB,WAAW;;IAEpD;MACE,SAAS;MACT,MAAM,CAAC,mBAAmB,CAAC,IAAIF,QAAO,eAAe,CAAC,CAAC;MACvD,YAAY;;IAEd;MACE,SAAS;MACT,UAAU,OAAO,eAAe,OAAO,eAAe,CAAA;;IAExD;MACE,SAAS;MACT,MAAM,CAAC,eAAe,2BAA2B;MACjD,YAAY;;IAEd;MACE,SAAS;MACT,UAAU,OAAO,iBAAiB,OAAO,iBAAiB;;IAE5D;MACE,SAAS;MACT,MAAM,CAAC,kBAAkB,uBAAuB;MAChD,YAAY;;IAEd;IACA;IACA;IACA;IACA;IACA,qBAAqB,OAAO,aAAa;IACzC,6BAA4B;;AAEhC;AAEA,SAAS,2BAAwB;AAC/B,EAAAC,QAAO,cAAc;AACrB,EAAAA,QAAO,iBAAiB;AACxB,EAAAA,QAAO,qBAAqB;AAC5B,EAAAA,QAAO,KAAK;AACZ,EAAAA,QAAO,mBAAmB,EAAE,UAAU,KAAI,CAAE;AAC5C,EAAAA,QAAO,+BAA+B,EAAE,UAAU,KAAI,CAAE;AAC1D;AAMA,IAAM,6BAAyC;EAC7C,EAAE,SAAS,qBAAqB,YAAY,yBAAwB;EACpE;IACE,SAAS;IACT,OAAO;IACP,aAAU;AACR,aAAO,MAAMA,QAAO,mBAAmB;IACzC;;;AAmBE,SAAU,aACd,UACA,QAA8B;AAE9B,SAAO,yBAAyB;IAC9B,GAAG,cAAc,UAAU,MAAM;IACjC;GACD;AACH;AAEA,SAAS,8BAA2B;AAClC,EAAAA,QAAO,mBAAmB;AAC1B,QAAM,WAAWA,QAAiC,eAAe;AACjE,QAAM,kBAAkBA,QAAgC,gBAAgB;AACxE,QAAM,iBAAiBA,QAAO,cAAc;AAC5C,EAAAA,QAAO,+BAA+B,EAAE,UAAU,KAAI,CAAE;AAExD,QAAM,QAAQ,SAAS,IAAI,CAAC,SAAS,UAAS;AAC5C,UAAM,2BAA2B,gBAAgB,MAAK;AAEtD,UAAM,WAAW,yBAAyC,KAAK;AAE/D,WAAO;MACL,GAAG;MACH;MACA,cAAc,qBAAqB,QAAQ,YAAY;;EAE3D,CAAC;AAED,iBAAe,YAAY,KAAK;AAClC;AAMA,IAAM,6BAAyC;EAC7C;IACE,SAAS;IACT,YAAY;;EAEd;IACE,SAAS;IACT,OAAO;IACP,aAAU;AACR,aAAO,MAAMA,QAAO,sBAAsB;IAC5C;;;AAIE,SAAU,cACd,oBACA,UAKA,SAAgE,CAAA,GAAE;AAElE,SAAO;IACL;MACE,SAAS;MACT,OAAO;MACP,UAAU,8BAA8B,SAAS,CAAA,IAAK;;IAExD;MACE,SAAS;MACT,OAAO;MACP,UAAU;QACR,KACE,8BAA8B,SAC1B,mBAAmB,OACnB;QACN,gBACE,EAAE,kBAAkBC,oBAAmB,OAAO,iBAC1C,OAAO,iBACP;QACN,cACE,EAAE,kBAAkBA,oBAAmB,OAAO,eAC1C,OAAO,eACP,CAAA;QACN,cACE,EAAE,kBAAkBA,oBAAmB,OAAO,eAC1C,OAAO,eACP;;;IAGV;MACE,SAAS;MACT,MAAM,CAAC,kBAAkB,cAAc;MACvC,YAAY;;IAEd;MACE,SAAS;MACT,OAAO;MACP,UACE,8BAA8B,SAC1B,mBAAmB,UACnB;;IAER;MACE,SAAS;MACT,OAAO;MACP,aACE,oBAAoBA,kBAAiB,WAAW;;IAEpD;MACE,SAAS;MACT,OAAO;MACP,MAAM,CAAC,mBAAmB,CAAC,IAAIF,QAAO,uBAAuB,CAAC,CAAC;MAC/D,YAAY;;IAEd,6BAA4B;;AAEhC;;;ACrUA,SACE,UAAAG,SAGA,UAEA,gBACK;;AA0BD,IAAO,kBAAP,MAAO,iBAAe;EAC1B,YACE,UACA,UACA,iBACA,OAGA,OAGA,aAAgB;EACf;;8GAZQ,kBAAe,MAAA,CAAA,EAAA,OAAA,eAAA,GAAA,EAAA,OAAA,kBAAA,GAAA,EAAA,OAAA,sBAAA,GAAA,EAAA,OAAA,MAAA,GAAA,EAAA,OAOhB,mBAAiB,UAAA,KAAA,GAAA,EAAA,OAGjB,+BAA6B,UAAA,KAAA,CAAA,GAAA,QAAA,oBAAA,SAAA,CAAA;EAAA;;+GAV5B,iBAAe,CAAA;EAAA;;+GAAf,iBAAe,CAAA;EAAA;;oGAAf,iBAAe,YAAA,CAAA;QAD3B;SAAS,CAAA,CAAE;;QAOP;;QACAA;SAAO,iBAAiB;;QAExB;;QACAA;SAAO,6BAA6B;;AAMnC,IAAO,qBAAP,MAAO,oBAAkB;EAC7B,YACmC,UACC,iBAC1B,gBACR,MAGA,aAAgB;AANiB,SAAA,WAAA;AACC,SAAA,kBAAA;AAC1B,SAAA,iBAAA;AAMR,UAAM,QAAQ,SAAS,IAAI,CAAC,SAAS,UAAS;AAC5C,YAAM,2BAA2B,gBAAgB,MAAK;AAEtD,YAAM,WAAW,yBAAyC,KAAK;AAE/D,aAAO;QACL,GAAG;QACH;QACA,cAAc,qBAAqB,QAAQ,YAAY;;IAE3D,CAAC;AAED,mBAAe,YAAY,KAAK;EAClC;;EAGA,cAAW;AACT,SAAK,eAAe,eAAe,KAAK,QAAQ;EAClD;;8GA5BW,qBAAkB,MAAA,CAAA,EAAA,OAEnB,gBAAe,GAAA,EAAA,OACf,iBAAgB,GAAA,EAAA,OAAA,eAAA,GAAA,EAAA,OAAA,gBAAA,GAAA,EAAA,OAIhB,+BAA6B,UAAA,KAAA,CAAA,GAAA,QAAA,oBAAA,SAAA,CAAA;EAAA;;+GAP5B,oBAAkB,CAAA;EAAA;;+GAAlB,oBAAkB,CAAA;EAAA;;oGAAlB,oBAAkB,YAAA,CAAA;QAD9B;SAAS,CAAA,CAAE;;QAGPA;SAAO,eAAe;;QACtBA;SAAO,gBAAgB;;QAGvB;;QACAA;SAAO,6BAA6B;;AAyBnC,IAAO,cAAP,MAAO,aAAW;EACtB,OAAO,QACL,UACA,QAA8B;AAE9B,WAAO;MACL,UAAU;MACV,WAAW,CAAC,GAAG,cAAc,UAAU,MAAM,CAAC;;EAElD;EAeA,OAAO,WACL,oBACA,UAKA,SAAgE,CAAA,GAAE;AAElE,WAAO;MACL,UAAU;MACV,WAAW,CAAC,GAAG,cAAc,oBAAoB,UAAU,MAAM,CAAC;;EAEtE;;8GArCW,cAAW,MAAA,CAAA,GAAA,QAAA,oBAAA,SAAA,CAAA;EAAA;;+GAAX,aAAW,CAAA;EAAA;;+GAAX,aAAW,CAAA;EAAA;;oGAAX,aAAW,YAAA,CAAA;QADvB;SAAS,CAAA,CAAE;;;;ACzBN,SAAU,MAUX,MAOF;AAED,QAAM,UAAU,KAAK,IAAG;AAIxB,QAAM,QAAS,KAA6B,IAC1C,CAAC,YAAY,QAAQ,IAAI;AAE3B,SAAO,EAAE,SAAS,MAAK;AACzB;AA+BM,SAAU,cAOd,iBAAoB,KAAgD;AACpE,QAAMC,OAAM,oBAAI,IAAG;AACnB,aAAWC,OAAM,KAAK;AACpB,eAAW,QAAQA,IAAG,OAAO;AAC3B,YAAM,kBAAkBD,KAAI,IAAI,IAAI;AACpC,UAAI,iBAAiB;AACnB,cAAM,aAAqC,CAAC,OAAO,WACjDC,IAAG,QAAQ,gBAAgB,OAAO,MAAM,GAAG,MAAM;AACnD,QAAAD,KAAI,IAAI,MAAM,UAAU;MAC1B,OAAO;AACL,QAAAA,KAAI,IAAI,MAAMC,IAAG,OAAO;MAC1B;IACF;EACF;AAEA,SAAO,SAAU,QAAW,cAAc,QAAS;AACjD,UAAM,UAAUD,KAAI,IAAI,OAAO,IAAI;AACnC,WAAO,UAAU,QAAQ,OAAO,MAAM,IAAI;EAC5C;AACF;",
  "names": ["props", "Injectable", "BehaviorSubject", "reducers", "Injectable", "Inject", "Injectable", "BehaviorSubject", "Observable", "Injectable", "Observable", "props", "args", "selectors", "InjectionToken", "isDevMode", "Inject", "inject", "InjectionToken", "Inject", "map", "on"]
}
